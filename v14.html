<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>AI Rhythm Generator</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Exo+2:wght@400;700;900&display=swap');

        :root {
            --primary: #39c5bb; /* PJ Sekai Cyan */
            --accent: #ff0055;
            --bg: #121212;
            --lane-bg: rgba(0, 20, 30, 0.6);
            --text: #ffffff;
        }

        * {
            box-sizing: border-box;
            user-select: none;
            -webkit-user-select: none;
            -webkit-touch-callout: none; /* iOS Safari Long Press Menu Disable */
        }

        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: var(--bg);
            font-family: 'Exo 2', sans-serif;
            color: var(--text);
        }

        /* --- Layers --- */
        #background-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 0;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            background: #000;
        }

        #background-video {
            width: 100%;
            height: 100%;
            object-fit: cover;
            opacity: 0.6;
        }

        #visualizer-canvas {
            position: absolute;
            width: 100%;
            height: 100%;
            opacity: 0.5;
        }

        #game-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 20;
            pointer-events: none; /* Let clicks pass through to game except buttons */
        }

        /* --- Screens --- */
        .screen {
            position: absolute;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: rgba(0,0,0,0.85);
            transition: opacity 0.5s;
            pointer-events: auto;
        }

        .hidden {
            opacity: 0;
            pointer-events: none;
            z-index: -1;
        }

        /* --- Title Screen --- */
        #logo-img {
            max-width: 300px;
            margin-bottom: 20px;
        }
        
        h1 { font-style: italic; text-transform: uppercase; letter-spacing: 2px; text-shadow: 0 0 10px var(--primary); }

        .file-input-wrapper {
            margin: 20px;
            position: relative;
            overflow: hidden;
            display: inline-block;
        }

        .btn {
            background: linear-gradient(45deg, var(--primary), #2a9d8f);
            border: 2px solid #fff;
            color: white;
            padding: 15px 40px;
            font-size: 1.2rem;
            font-weight: bold;
            border-radius: 30px;
            cursor: pointer;
            text-transform: uppercase;
            box-shadow: 0 0 15px var(--primary);
            transition: transform 0.1s;
            margin: 10px;
            pointer-events: auto;
        }

        .btn:active { transform: scale(0.95); }
        .btn:disabled { background: #555; box-shadow: none; cursor: not-allowed; }

        input[type=file] {
            font-size: 100px;
            position: absolute;
            left: 0;
            top: 0;
            opacity: 0;
        }

        .settings-group {
            background: rgba(255,255,255,0.1);
            padding: 15px;
            border-radius: 10px;
            margin: 10px;
            text-align: center;
            width: 90%;
            max-width: 500px;
        }

        label { display: block; margin-bottom: 5px; font-weight: bold; }
        select, input[type=range] {
            width: 100%;
            padding: 10px;
            margin-bottom: 10px;
            background: #222;
            color: white;
            border: 1px solid var(--primary);
            border-radius: 5px;
        }

        /* --- Game UI --- */
        #hud-top {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 60px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0 20px;
            background: linear-gradient(to bottom, rgba(0,0,0,0.8), transparent);
        }

        .life-bar-container {
            width: 200px;
            height: 15px;
            background: #333;
            border: 2px solid #fff;
            border-radius: 10px;
            overflow: hidden;
            position: relative;
        }

        #life-bar {
            width: 100%;
            height: 100%;
            background: #4caf50; /* Green */
            transition: width 0.2s, background 0.2s;
        }

        .score-display {
            font-size: 1.5rem;
            font-weight: 900;
            text-align: right;
        }

        #combo-container {
            position: absolute;
            top: 30%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            pointer-events: none;
            display: none; /* JS will show */
        }

        #combo-count {
            font-size: 4rem;
            font-weight: 900;
            color: #fff;
            background: linear-gradient(to bottom, #fff, var(--primary));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            line-height: 1;
        }

        #combo-label {
            font-size: 1rem;
            letter-spacing: 5px;
            color: var(--primary);
            font-weight: bold;
        }

        #judge-display {
            position: absolute;
            top: 55%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 2.5rem;
            font-weight: 900;
            text-shadow: 0 0 10px rgba(255,255,255,0.8);
            opacity: 0;
        }
        
        .judge-perfect { color: #ffeb3b; }
        .judge-great { color: #e91e63; }
        .judge-good { color: #2196f3; }
        .judge-miss { color: #9e9e9e; }

        /* Pause Button */
        #pause-btn {
            position: absolute;
            top: 10px;
            right: 20px; /* Adjusted to not overlap score too much if mobile */
            z-index: 100;
            background: rgba(0,0,0,0.5);
            border: 1px solid white;
            width: 40px;
            height: 40px;
            border-radius: 5px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            pointer-events: auto;
        }

        /* --- Loading --- */
        #loading-bar-container {
            width: 60%;
            height: 5px;
            background: #333;
            margin-top: 20px;
        }
        #loading-bar { width: 0%; height: 100%; background: var(--primary); transition: width 0.1s; }

        /* Input Zone overlay for touch debug (optional, keeping invisible) */
        #input-zones {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 30%; /* Bottom 30% is touch area */
            display: flex;
            z-index: 15;
        }
        .zone { flex: 1; /* border: 1px solid rgba(255,255,255,0.1); */ }

    </style>
</head>
<body>

    <div id="background-layer">
        <canvas id="visualizer-canvas"></canvas>
        <video id="background-video" playsinline muted loop style="display:none;"></video>
    </div>

    <canvas id="game-layer"></canvas>

    <div id="ui-layer">
        <div id="hud-top" class="hidden">
            <div class="life-bar-container">
                <div id="life-bar"></div>
            </div>
            <div id="pause-btn" onclick="game.togglePause()">||</div>
            <div class="score-display">SCORE: <span id="score-val">0</span></div>
        </div>

        <div id="combo-container">
            <div id="combo-count">0</div>
            <div id="combo-label">COMBO</div>
        </div>
        <div id="judge-display">PERFECT</div>
        
        <div id="input-zones">
            <div class="zone" data-lane="0"></div>
            <div class="zone" data-lane="1"></div>
            <div class="zone" data-lane="2"></div>
            <div class="zone" data-lane="3"></div>
        </div>
    </div>

    <div id="title-screen" class="screen">
        <img src="https://example.com/logo.png" alt="GAME LOGO" id="logo-img" onerror="this.style.display='none'">
        <h1>AI RHYTHM</h1>
        
        <div class="settings-group">
            <div class="file-input-wrapper btn">
                SELECT FILE (Audio/Video)
                <input type="file" id="file-input" accept="audio/*,video/*">
            </div>
            <div id="file-name" style="margin-top:5px; font-size:0.9rem; color:#aaa;">No file selected</div>
        </div>

        <div class="settings-group">
            <label>DIFFICULTY</label>
            <select id="diff-select">
                <option value="0">EASY</option>
                <option value="1">NORMAL</option>
                <option value="2">HARD</option>
                <option value="3">EXPERT</option>
                <option value="4">MASTER</option>
            </select>
            
            <label>NOTE SPEED: <span id="speed-val">6.0</span></label>
            <input type="range" id="speed-range" min="1" max="12" step="0.5" value="6.0">
        </div>

        <button id="start-btn" class="btn" disabled>GAME START</button>
    </div>

    <div id="loading-screen" class="screen hidden">
        <h2>ANALYZING MUSIC...</h2>
        <div id="loading-text">Generating Chart</div>
        <div id="loading-bar-container"><div id="loading-bar"></div></div>
    </div>

    <div id="result-screen" class="screen hidden">
        <h2 style="font-size:3rem; margin-bottom:10px;">FULL COMBO!</h2>
        <div style="font-size:1.5rem;">SCORE: <span id="result-score">0</span></div>
        <div style="font-size:1.2rem; margin:10px;">MAX COMBO: <span id="result-combo">0</span></div>
        <div style="display:grid; grid-template-columns: 1fr 1fr; gap:10px; text-align:left; margin:20px;">
            <div>PERFECT</div><div id="res-perf">0</div>
            <div>GREAT</div><div id="res-great">0</div>
            <div>GOOD</div><div id="res-good">0</div>
            <div>MISS</div><div id="res-miss">0</div>
        </div>
        <button class="btn" onclick="location.reload()">BACK TO TITLE</button>
    </div>

<script>
/**
 * AI RHYTHM GAME LOGIC
 * Single File Implementation
 */

// --- Constants & Config ---
const LANES = 4;
const LOOKAHEAD = 3.0; // Seconds of notes to draw
const JUDGE_LINE_Y = 0.85; // % of screen height
const PERFECT_WINDOW = 0.050; // 50ms
const GREAT_WINDOW = 0.100;
const GOOD_WINDOW = 0.180;

// Pseudo Random Number Generator for Deterministic Charts
class PseudoRandom {
    constructor(seed) {
        this.seed = seed % 2147483647;
        if (this.seed <= 0) this.seed += 2147483646;
    }
    next() {
        return this.seed = this.seed * 16807 % 2147483647;
    }
    nextFloat() {
        return (this.next() - 1) / 2147483646;
    }
}

// --- Main Game Class ---
class RhythmGame {
    constructor() {
        this.audioCtx = null;
        this.audioBuffer = null;
        this.sourceNode = null;
        this.analyser = null;
        this.videoEl = document.getElementById('background-video');
        
        this.notes = []; // { time, lane, type, length, processed }
        this.score = 0;
        this.combo = 0;
        this.maxCombo = 0;
        this.life = 1000;
        this.isPlaying = false;
        this.startTime = 0;
        this.pauseTime = 0;
        this.noteSpeed = 6.0;
        this.difficulty = 1; // 0-4
        
        this.stats = { perfect:0, great:0, good:0, miss:0 };
        
        // Input State
        this.keyMap = { 'KeyD':0, 'KeyF':1, 'KeyJ':2, 'KeyK':3 };
        this.laneState = [false, false, false, false]; // Is lane currently held?
        
        // Setup Renderer
        this.canvas = document.getElementById('game-layer');
        this.ctx = this.canvas.getContext('2d');
        
        // Visualizer
        this.visCanvas = document.getElementById('visualizer-canvas');
        this.visCtx = this.visCanvas.getContext('2d');
        
        this.resize();
        window.addEventListener('resize', () => this.resize());
        
        this.bindInputs();
    }

    resize() {
        this.canvas.width = window.innerWidth;
        this.canvas.height = window.innerHeight;
        this.visCanvas.width = window.innerWidth;
        this.visCanvas.height = window.innerHeight;
    }

    bindInputs() {
        // Keyboard
        window.addEventListener('keydown', (e) => {
            if (!this.isPlaying) return;
            if (e.code in this.keyMap) {
                const lane = this.keyMap[e.code];
                if (!this.laneState[lane]) {
                    this.triggerInput(lane, 'down');
                    this.laneState[lane] = true;
                }
            }
        });
        window.addEventListener('keyup', (e) => {
            if (!this.isPlaying) return;
            if (e.code in this.keyMap) {
                const lane = this.keyMap[e.code];
                this.triggerInput(lane, 'up');
                this.laneState[lane] = false;
            }
        });

        // Touch
        const zones = document.querySelectorAll('.zone');
        zones.forEach(z => {
            z.addEventListener('touchstart', (e) => {
                e.preventDefault();
                if (!this.isPlaying) return;
                this.triggerInput(parseInt(z.dataset.lane), 'down');
                this.laneState[parseInt(z.dataset.lane)] = true;
            });
            z.addEventListener('touchend', (e) => {
                e.preventDefault();
                if (!this.isPlaying) return;
                this.triggerInput(parseInt(z.dataset.lane), 'up');
                this.laneState[parseInt(z.dataset.lane)] = false;
            });
        });
    }

    async loadFile(file) {
        document.getElementById('title-screen').classList.add('hidden');
        document.getElementById('loading-screen').classList.remove('hidden');

        this.audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        
        // Setup Media
        const url = URL.createObjectURL(file);
        const isVideo = file.type.startsWith('video');

        if (isVideo) {
            this.videoEl.src = url;
            this.videoEl.style.display = 'block';
            this.videoEl.load(); // Prepare video
        } else {
            this.videoEl.style.display = 'none';
        }

        // Decode Audio for Analysis
        const arrayBuffer = await file.arrayBuffer();
        
        // Generate seed from file props
        const seedStr = file.name + file.size;
        let seedVal = 0;
        for (let i=0; i<seedStr.length; i++) seedVal += seedStr.charCodeAt(i);
        
        document.getElementById('loading-text').innerText = "Decoding Audio...";
        
        try {
            this.audioBuffer = await this.audioCtx.decodeAudioData(arrayBuffer);
            this.generateChart(this.audioBuffer, seedVal);
            this.startGame();
        } catch (e) {
            alert("Error decoding audio: " + e);
            location.reload();
        }
    }

    generateChart(buffer, seed) {
        document.getElementById('loading-text').innerText = "Generating AI Chart...";
        this.notes = [];
        const rawData = buffer.getChannelData(0);
        const sampleRate = buffer.sampleRate;
        const rng = new PseudoRandom(seed);
        
        // Parameters based on difficulty
        // Easy(0) -> Master(4)
        const d = this.difficulty;
        const thresholdBase = [0.15, 0.12, 0.08, 0.05, 0.03][d]; 
        const minStep = [0.5, 0.4, 0.25, 0.15, 0.1][d]; // Minimum time between notes per lane
        const density = [0.3, 0.5, 0.7, 0.9, 1.0][d]; // Chance to spawn note on peak
        
        // Simple Peak Detection
        const windowSize = Math.floor(sampleRate * 0.05); // 50ms window
        let lastNoteTime = -1;
        
        for (let i = 0; i < rawData.length; i += windowSize) {
            let sum = 0;
            for (let j = 0; j < windowSize; j++) {
                if (i+j < rawData.length) sum += Math.abs(rawData[i+j]);
            }
            const avg = sum / windowSize;
            
            // Current Time
            const time = i / sampleRate;

            if (avg > thresholdBase) {
                if (time - lastNoteTime < minStep) continue; // Too fast

                if (rng.nextFloat() < density) {
                    // Create Note
                    const lane = Math.floor(rng.nextFloat() * LANES);
                    let type = 'tap';
                    let length = 0;

                    // Random Long Notes & Flicks (Higher diff = more complex)
                    const rType = rng.nextFloat();
                    if (rType < 0.1 + (d*0.05)) {
                        type = 'flick';
                    } else if (rType > 0.85 - (d*0.05)) {
                        type = 'long';
                        length = 0.5 + rng.nextFloat() * 1.5; // 0.5s to 2.0s hold
                    }

                    this.notes.push({
                        time: time,
                        lane: lane,
                        type: type,
                        length: length,
                        hit: false,
                        holding: false
                    });
                    lastNoteTime = time;
                }
            }
        }
        
        // Sort notes by time just in case
        this.notes.sort((a,b) => a.time - b.time);
        
        // Add end trigger
        this.notes.push({ time: buffer.duration + 2, lane: 0, type: 'end', length:0 });
    }

    startGame() {
        document.getElementById('loading-screen').classList.add('hidden');
        document.getElementById('hud-top').classList.remove('hidden');
        
        // Audio Source
        this.sourceNode = this.audioCtx.createBufferSource();
        this.sourceNode.buffer = this.audioBuffer;
        
        // Analyser for Visualizer
        this.analyser = this.audioCtx.createAnalyser();
        this.analyser.fftSize = 256;
        
        this.sourceNode.connect(this.analyser);
        this.analyser.connect(this.audioCtx.destination);
        
        this.startTime = this.audioCtx.currentTime;
        this.sourceNode.start(0);
        if (this.videoEl.style.display !== 'none') {
            this.videoEl.currentTime = 0;
            this.videoEl.play();
        }

        this.isPlaying = true;
        this.loop();
    }

    togglePause() {
        if (!this.isPlaying) return;
        // Simplified pause: just reload for this demo or stop logic
        // Proper pause requires suspending AudioContext and tracking offset
        if (this.audioCtx.state === 'running') {
            this.audioCtx.suspend();
            if(this.videoEl) this.videoEl.pause();
        } else {
            this.audioCtx.resume();
            if(this.videoEl) this.videoEl.play();
        }
    }

    triggerInput(lane, action) {
        const now = this.getCurrentTime();
        
        // Find closest hittable note in lane
        // Filter active notes
        const hittable = this.notes.filter(n => 
            !n.hit && 
            n.lane === lane && 
            n.type !== 'end' &&
            Math.abs(n.time - now) < GOOD_WINDOW + n.length // Check start or within hold
        );

        if (hittable.length === 0) return;

        // Sort by proximity
        hittable.sort((a,b) => Math.abs(a.time - now) - Math.abs(b.time - now));
        const note = hittable[0];

        if (action === 'down') {
            if (note.type === 'tap' || note.type === 'flick') {
                this.judge(note, now);
            } else if (note.type === 'long') {
                // Check start of long note
                if (Math.abs(note.time - now) < GOOD_WINDOW) {
                    note.holding = true;
                    this.showJudge('PERFECT'); // Visual feedback for start
                }
            }
        } else if (action === 'up') {
            if (note.type === 'long' && note.holding) {
                // Judge release
                const releaseTime = note.time + note.length;
                this.judge(note, now, releaseTime);
            }
        }
    }

    judge(note, now, targetTime = null) {
        const target = targetTime || note.time;
        const diff = Math.abs(target - now);
        
        let grade = 'MISS';
        if (diff < PERFECT_WINDOW) grade = 'PERFECT';
        else if (diff < GREAT_WINDOW) grade = 'GREAT';
        else if (diff < GOOD_WINDOW) grade = 'GOOD';

        if (grade !== 'MISS') {
            note.hit = true;
            this.addScore(grade);
        } else {
            note.hit = true; // Count as processed but missed
            this.breakCombo();
        }
    }

    addScore(grade) {
        this.combo++;
        if(this.combo > this.maxCombo) this.maxCombo = this.combo;
        
        // Score calc
        let base = 500;
        if(grade === 'PERFECT') base = 1000;
        if(grade === 'GREAT') base = 800;
        if(grade === 'GOOD') base = 500;

        this.score += base * (1 + this.combo * 0.01);
        this.score = Math.floor(this.score);
        
        // Update Stats
        if(grade==='PERFECT') this.stats.perfect++;
        if(grade==='GREAT') this.stats.great++;
        if(grade==='GOOD') this.stats.good++;

        // Life recover
        this.life = Math.min(1000, this.life + 20);

        this.showJudge(grade);
        this.updateHUD();
    }

    breakCombo() {
        this.combo = 0;
        this.stats.miss++;
        this.life = Math.max(0, this.life - 100); // Don't die, just reduce
        this.showJudge('MISS');
        this.updateHUD();
    }

    showJudge(text) {
        const el = document.getElementById('judge-display');
        el.className = '';
        el.innerText = text;
        el.classList.add('judge-' + text.toLowerCase());
        
        // Animation reset
        el.style.animation = 'none';
        el.offsetHeight; /* trigger reflow */
        el.style.animation = 'pop 0.3s forwards';
        el.style.opacity = 1;

        if (this.combo > 1) {
            const c = document.getElementById('combo-container');
            document.getElementById('combo-count').innerText = this.combo;
            c.style.display = 'block';
            c.style.animation = 'none';
            c.offsetHeight;
            c.style.animation = 'bump 0.1s';
        } else {
            document.getElementById('combo-container').style.display = 'none';
        }
    }

    updateHUD() {
        document.getElementById('score-val').innerText = this.score;
        const bar = document.getElementById('life-bar');
        bar.style.width = (this.life / 10) + '%';
        bar.style.background = this.life > 300 ? '#4caf50' : '#f44336';
    }

    getCurrentTime() {
        if(!this.audioCtx) return 0;
        return this.audioCtx.currentTime - this.startTime;
    }

    endGame() {
        this.isPlaying = false;
        this.sourceNode.stop();
        if(this.videoEl) this.videoEl.pause();
        
        document.getElementById('ui-layer').style.display = 'none';
        document.getElementById('result-screen').classList.remove('hidden');
        
        // Fill Result
        if (this.stats.miss === 0) document.querySelector('#result-screen h2').innerText = "FULL COMBO!";
        else document.querySelector('#result-screen h2').innerText = "FINISH";

        document.getElementById('result-score').innerText = this.score;
        document.getElementById('result-combo').innerText = this.maxCombo;
        document.getElementById('res-perf').innerText = this.stats.perfect;
        document.getElementById('res-great').innerText = this.stats.great;
        document.getElementById('res-good').innerText = this.stats.good;
        document.getElementById('res-miss').innerText = this.stats.miss;
    }

    // --- RENDER LOOP ---
    loop() {
        if (!this.isPlaying) return;
        requestAnimationFrame(() => this.loop());

        const now = this.getCurrentTime();
        
        // Draw Visualizer
        this.drawVisualizer();

        // Clear Game Layer
        this.ctx.clearRect(0,0, this.canvas.width, this.canvas.height);

        // Perspective Settings
        const w = this.canvas.width;
        const h = this.canvas.height;
        const laneWidth = Math.min(w * 0.9, 500); // Total track width
        const lw = laneWidth / 4; // Single lane width
        const trackX = (w - laneWidth) / 2;
        
        // Pseudo-3D Projection
        // Z=0 is bottom (player), Z=1 is horizon
        const project = (x, z) => {
            const scale = 1 / (z + 1); // Simple perspective divisor
            const x2D = w/2 + (x - w/2) * scale;
            const y2D = h * JUDGE_LINE_Y - (h * 0.6 * z * scale); // Horizon at ~25% height
            // Actually, let's do standard rhythm game perspective
            // Top of track is narrow, Bottom is wide
            // Let's create a trapezoid visually
            const vanishingY = h * 0.2;
            const playerY = h * JUDGE_LINE_Y;
            
            const p = z; // 0 to 1 progress
            const currentY = playerY - (playerY - vanishingY) * p;
            
            // Width scaling
            const perspectiveFactor = (1 - 0.7 * p); // Top is 30% width of bottom
            const centerX = w / 2;
            const currentX = centerX + (x - centerX) * perspectiveFactor;
            
            return { x: currentX, y: currentY, scale: perspectiveFactor };
        };

        // Draw Lanes
        this.ctx.save();
        this.ctx.globalCompositeOperation = 'screen';
        
        // Draw Track Background
        const btmL = project(trackX, 0);
        const btmR = project(trackX + laneWidth, 0);
        const topL = project(trackX, 1);
        const topR = project(trackX + laneWidth, 1);
        
        this.ctx.fillStyle = 'rgba(0, 10, 20, 0.7)';
        this.ctx.beginPath();
        this.ctx.moveTo(btmL.x, btmL.y);
        this.ctx.lineTo(btmR.x, btmR.y);
        this.ctx.lineTo(topR.x, topR.y);
        this.ctx.lineTo(topL.x, topL.y);
        this.ctx.fill();

        // Draw Lane Dividers & Hit Line
        this.ctx.strokeStyle = 'rgba(57, 197, 187, 0.5)';
        this.ctx.lineWidth = 2;
        
        // Dividers
        for(let i=0; i<=4; i++) {
            const p1 = project(trackX + i*lw, 0);
            const p2 = project(trackX + i*lw, 1);
            this.ctx.beginPath();
            this.ctx.moveTo(p1.x, p1.y);
            this.ctx.lineTo(p2.x, p2.y);
            this.ctx.stroke();
        }

        // Judge Line
        this.ctx.strokeStyle = '#fff';
        this.ctx.lineWidth = 4;
        this.ctx.beginPath();
        this.ctx.moveTo(btmL.x, btmL.y);
        this.ctx.lineTo(btmR.x, btmR.y);
        this.ctx.stroke();

        // Input Feedback (Key Press visual)
        for(let i=0; i<4; i++) {
            if(this.laneState[i]) {
                const p1 = project(trackX + i*lw, 0);
                const p2 = project(trackX + (i+1)*lw, 0);
                const p3 = project(trackX + i*lw, 0.2); // short ray up
                
                const grad = this.ctx.createLinearGradient(0, p1.y, 0, p3.y);
                grad.addColorStop(0, 'rgba(255, 0, 85, 0.6)');
                grad.addColorStop(1, 'transparent');
                
                this.ctx.fillStyle = grad;
                this.ctx.fillRect(p1.x, p3.y, p2.x - p1.x, p1.y - p3.y);
            }
        }

        // Draw Notes
        const speedMultiplier = this.noteSpeed * 0.5; // Tuning

        this.notes.forEach(note => {
            if (note.hit && note.type !== 'long') return;
            if (note.hit && note.type === 'long' && !note.holding && this.getCurrentTime() > note.time + note.length) return;

            // Calculate Z position (0 = hit line, 1 = top)
            // Time difference
            const dt = note.time - now;
            
            // Don't draw if too far or behind
            if (dt > LOOKAHEAD / speedMultiplier) return;
            
            // Map dt to Z (1 -> 0)
            // dt=0 => z=0
            // dt=LOOKAHEAD => z=1
            let z = dt / (LOOKAHEAD / speedMultiplier);
            
            // Handle Long Note Tail
            let zTail = z;
            if (note.type === 'long') {
                const dtTail = (note.time + note.length) - now;
                zTail = dtTail / (LOOKAHEAD / speedMultiplier);
            }

            // Cull
            if (z > 1 && zTail > 1) return;
            if (z < -0.2 && zTail < -0.2) {
                // Missed without processing (should be caught by logic but safe guard)
                if (!note.hit) {
                     note.hit = true;
                     this.breakCombo();
                }
                return;
            } else if (note.type === 'end' && z < 0) {
                this.endGame();
            }
            
            if (note.type === 'end') return;

            // Clamp for drawing
            const drawZHead = Math.max(-0.1, Math.min(1, z));
            const drawZTail = Math.max(-0.1, Math.min(1, zTail));

            // Coordinates
            const laneX = trackX + note.lane * lw;
            
            // Draw Long Note Body
            if (note.type === 'long') {
                const headP = project(laneX, drawZHead);
                const headPR = project(laneX + lw, drawZHead);
                const tailP = project(laneX, drawZTail);
                const tailPR = project(laneX + lw, drawZTail);

                this.ctx.fillStyle = 'rgba(57, 197, 187, 0.6)'; // Cyan translucent
                this.ctx.beginPath();
                this.ctx.moveTo(headP.x, headP.y);
                this.ctx.lineTo(headPR.x, headPR.y);
                this.ctx.lineTo(tailPR.x, tailPR.y);
                this.ctx.lineTo(tailP.x, tailP.y);
                this.ctx.fill();
            }

            // Draw Note Head
            if (!note.hit || (note.type === 'long' && note.holding)) {
                // If holding, keep head at judge line (z=0)
                const currentZ = (note.holding) ? 0 : drawZHead;
                const p = project(laneX, currentZ);
                const pR = project(laneX + lw, currentZ);
                
                const width = pR.x - p.x;
                const height = 15 * p.scale; // Scale height by perspective

                this.ctx.fillStyle = note.type === 'flick' ? '#ff0055' : '#39c5bb';
                if(note.type === 'long') this.ctx.fillStyle = '#ffeb3b'; // Yellow for hold head
                
                // Note shape
                this.ctx.fillRect(p.x + 2, p.y - height/2, width - 4, height);
                
                // Decor: Inner white
                this.ctx.fillStyle = '#fff';
                this.ctx.fillRect(p.x + 4, p.y - height/4, width - 8, height/2);

                // Flick Arrow
                if (note.type === 'flick') {
                    this.ctx.fillStyle = '#ff0055';
                    this.ctx.beginPath();
                    this.ctx.moveTo(p.x + width/2, p.y - height);
                    this.ctx.lineTo(p.x + width/2 - 10*p.scale, p.y - height/2);
                    this.ctx.lineTo(p.x + width/2 + 10*p.scale, p.y - height/2);
                    this.ctx.fill();
                }
            }

        });

        this.ctx.restore();
    }

    drawVisualizer() {
        if(!this.analyser) return;
        const bufferLength = this.analyser.frequencyBinCount;
        const dataArray = new Uint8Array(bufferLength);
        this.analyser.getByteFrequencyData(dataArray);

        const WIDTH = this.visCanvas.width;
        const HEIGHT = this.visCanvas.height;

        this.visCtx.clearRect(0, 0, WIDTH, HEIGHT);
        
        // If video is playing, minimal visualizer or none
        if (this.videoEl.style.display !== 'none' && !this.videoEl.paused) {
            // Optional: Draw overlay or nothing. 
            // Let's draw nothing to keep video clear, or subtle tint
            return; 
        }

        // Draw Waveform if no video
        this.visCtx.fillStyle = 'rgba(0, 0, 0, 0.2)';
        this.visCtx.fillRect(0, 0, WIDTH, HEIGHT);

        const barWidth = (WIDTH / bufferLength) * 2.5;
        let barHeight;
        let x = 0;

        for(let i = 0; i < bufferLength; i++) {
            barHeight = dataArray[i] * 1.5;

            // Mirror effect
            this.visCtx.fillStyle = 'rgba(57, 197, 187, ' + (barHeight/400) + ')';
            this.visCtx.fillRect(x, HEIGHT/2 - barHeight/2, barWidth, barHeight);

            x += barWidth + 1;
        }
    }
}

// --- Initialization ---
const game = new RhythmGame();

// UI Event Listeners
document.getElementById('file-input').addEventListener('change', function(e) {
    if(e.target.files.length > 0) {
        document.getElementById('file-name').innerText = e.target.files[0].name;
        document.getElementById('start-btn').disabled = false;
        
        // Settings update
        game.difficulty = parseInt(document.getElementById('diff-select').value);
        game.noteSpeed = parseFloat(document.getElementById('speed-range').value);
    }
});

document.getElementById('speed-range').addEventListener('input', function(e) {
    document.getElementById('speed-val').innerText = parseFloat(e.target.value).toFixed(1);
    game.noteSpeed = parseFloat(e.target.value);
});

document.getElementById('diff-select').addEventListener('change', function(e) {
    game.difficulty = parseInt(e.target.value);
});

document.getElementById('start-btn').addEventListener('click', function() {
    const file = document.getElementById('file-input').files[0];
    if(file) game.loadFile(file);
});

// Animations CSS inject
const styleSheet = document.createElement("style");
styleSheet.innerText = `
@keyframes pop {
    0% { transform: translate(-50%, -50%) scale(0.5); opacity: 0; }
    50% { transform: translate(-50%, -50%) scale(1.2); opacity: 1; }
    100% { transform: translate(-50%, -50%) scale(1.0); opacity: 0; }
}
@keyframes bump {
    0% { transform: translate(-50%, -50%) scale(1); }
    50% { transform: translate(-50%, -50%) scale(1.1); }
    100% { transform: translate(-50%, -50%) scale(1); }
}
`;
document.head.appendChild(styleSheet);

</script>
</body>
</html>
