<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>SEKAI GEN - ULTIMATE FIX</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jsmediatags/3.9.5/jsmediatags.min.js"></script>
    <style>
        :root {
            --primary: #33d5ac; /* Miku Green */
            --accent: #ff007c; /* Pink */
            --bg-color: #050510;
        }
        * { box-sizing: border-box; user-select: none; -webkit-user-select: none; touch-action: none; }
        body { margin: 0; overflow: hidden; background: var(--bg-color); font-family: 'Segoe UI', sans-serif; color: white; }

        /* --- Layers --- */
        #bg-layer { position: absolute; top:0; left:0; width:100%; height:100%; z-index:0; overflow:hidden; }
        #bg-media { width: 100%; height: 100%; object-fit: cover; opacity: 0.5; filter: blur(3px) brightness(0.7); transition: opacity 0.5s; }
        /* „Éì„Éá„Ç™Ë¶ÅÁ¥†„ÅØÈùûË°®Á§∫„ÅßÂÜçÁîüÁî®„ÄÅÁîªÂÉè„ÅØË°®Á§∫Áî® */
        #media-source { display: none; } 
        
        #game-layer { position: absolute; top:0; left:0; width:100%; height:100%; z-index:1; }

        .screen {
            position: absolute; top:0; left:0; width:100%; height:100%; z-index:10;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            background: rgba(0,0,0,0.85); backdrop-filter: blur(5px);
            transition: opacity 0.4s; opacity: 0; pointer-events: none;
        }
        .screen.active { opacity: 1; pointer-events: auto; }

        /* --- UI Elements --- */
        .logo-img { width: 300px; max-width:80%; margin-bottom: 20px; filter: drop-shadow(0 0 15px var(--primary)); animation: float 3s ease-in-out infinite; }
        @keyframes float { 0%,100%{transform:translateY(0)} 50%{transform:translateY(-10px)} }

        .btn {
            background: linear-gradient(135deg, var(--primary), #00b894);
            border: none; padding: 15px 50px; border-radius: 40px;
            color: #fff; font-size: 1.2rem; font-weight: bold; letter-spacing: 2px;
            cursor: pointer; box-shadow: 0 5px 20px rgba(51, 213, 172, 0.5);
            transition: transform 0.1s; margin-top: 10px;
        }
        .btn:active { transform: scale(0.95); }
        .btn:disabled { background: #555; box-shadow: none; cursor: not-allowed; }

        /* Select Screen */
        .panel { background: rgba(255,255,255,0.95); width:90%; max-width:600px; border-radius:20px; padding:30px; color:#333; box-shadow:0 0 40px rgba(0,0,0,0.5); }
        .file-box { border: 3px dashed #aaa; padding: 25px; text-align: center; border-radius: 10px; cursor: pointer; background: #f0f0f0; margin-bottom: 20px; transition: 0.3s; }
        .file-box:hover { border-color: var(--primary); background: #e0fbf4; }
        
        .diff-row { display: flex; gap: 5px; margin-bottom: 20px; }
        .diff-btn { flex: 1; padding: 12px 0; border: none; color: white; font-weight: 900; font-size: 0.9rem; cursor: pointer; opacity: 0.4; transform: skewX(-10deg); border-radius: 4px; transition: 0.2s; }
        .diff-btn span { display: block; transform: skewX(10deg); }
        .diff-btn.active { opacity: 1; transform: scale(1.05) skewX(-10deg); z-index:2; box-shadow: 0 5px 15px rgba(0,0,0,0.3); }
        
        .c-easy { background: #00b894; } .c-norm { background: #0984e3; } .c-hard { background: #fdcb6e; } .c-exp { background: #d63031; } .c-mas { background: #6c5ce7; }

        /* Game UI */
        .game-ui { position: absolute; width:100%; height:100%; pointer-events: none; padding: 20px; z-index: 5; display: flex; flex-direction: column; justify-content: space-between; }
        .hud-top { display: flex; justify-content: space-between; width: 100%; }
        .score-box { text-align: left; }
        .score-num { font-family: 'Courier New', monospace; font-size: 2.5rem; font-weight: 900; color: white; text-shadow: 0 0 10px var(--primary); }
        .life-gauge { width: 250px; height: 10px; background: rgba(255,255,255,0.2); border-radius: 5px; overflow: hidden; margin-top: 5px; }
        .life-fill { height: 100%; width: 100%; background: #00b894; transition: width 0.1s; box-shadow: 0 0 10px #00b894; }
        
        .combo-box { position: absolute; top: 40%; left: 50%; transform: translate(-50%, -50%); text-align: center; opacity: 0; transition: opacity 0.1s; }
        .combo-box.show { opacity: 1; }
        .combo-val { font-size: 5rem; font-weight: 900; font-style: italic; background: linear-gradient(to bottom, #fff, var(--primary)); -webkit-background-clip: text; -webkit-text-fill-color: transparent; line-height: 1; }
        
        .judge-text { position: absolute; top: 60%; left: 50%; transform: translate(-50%, -50%); font-size: 2.5rem; font-weight: 900; font-style: italic; opacity: 0; text-shadow: 0 0 20px white; }

        #loading { display: none; position: fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.9); z-index:99; flex-direction:column; align-items:center; justify-content:center; color:white; }
        .spinner { width: 50px; height: 50px; border: 5px solid rgba(255,255,255,0.2); border-top-color: var(--primary); border-radius: 50%; animation: spin 1s infinite linear; margin-bottom: 20px; }
        @keyframes spin{to{transform:rotate(360deg)}}
    </style>
</head>
<body>

    <div id="bg-layer">
        <img id="bg-img" style="display:none; width:100%; height:100%; object-fit:cover; opacity:0.6; filter:blur(4px);">
        <video id="bg-video" style="display:none; width:100%; height:100%; object-fit:cover; opacity:0.6; filter:blur(4px);" playsinline muted loop></video>
        
        <video id="media-source" playsinline></video>
    </div>

    <div id="loading">
        <div class="spinner"></div>
        <div id="loading-txt">Generating High-Density Chart...</div>
    </div>

    <div id="title-screen" class="screen active">
        <h1 style="font-size:3rem; margin-bottom:10px; color:var(--primary); text-shadow:0 0 20px var(--primary);">SEKAI GEN</h1>
        <p style="letter-spacing:4px; opacity:0.8; margin-bottom:40px;">ULTIMATE EDITION</p>
        <button class="btn" onclick="navTo('select-screen')">START</button>
    </div>

    <div id="select-screen" class="screen">
        <div class="panel">
            <h2 style="color:var(--primary); text-align:center; margin-top:0;">SELECT MUSIC</h2>
            
            <div class="file-box" onclick="document.getElementById('file-in').click()">
                <div style="font-size:2rem;">üìÇ</div>
                <div style="font-weight:bold; margin-top:10px;">„Éï„Ç°„Ç§„É´„ÇíÈÅ∏Êäû</div>
                <div style="font-size:0.8rem; color:#666;">MP3 (Album ArtÂØæÂøú), WAV, MP4</div>
            </div>
            <input type="file" id="file-in" accept="audio/*,video/*" style="display:none" onchange="loadFile(this)">

            <label style="font-weight:bold; color:#555;">DIFFICULTY</label>
            <div class="diff-row">
                <button class="diff-btn c-easy" onclick="setDiff(0)"><span>EASY</span></button>
                <button class="diff-btn c-norm" onclick="setDiff(1)"><span>NORMAL</span></button>
                <button class="diff-btn c-hard active" onclick="setDiff(2)"><span>HARD</span></button>
                <button class="diff-btn c-exp" onclick="setDiff(3)"><span>EXPERT</span></button>
                <button class="diff-btn c-mas" onclick="setDiff(4)"><span>MASTER</span></button>
            </div>

            <label style="font-weight:bold; color:#555;">SPEED: <span id="spd-val">9.0</span></label>
            <input type="range" min="1" max="15" step="0.5" value="9" style="width:100%; accent-color:var(--primary);" oninput="setSpeed(this.value)">

            <button id="btn-play" class="btn" style="width:100%;" disabled onclick="startGame()">FILE REQUIRED</button>
        </div>
    </div>

    <div id="game-layer" style="display:none;">
        <canvas id="game-canvas"></canvas>
        <div class="game-ui" id="game-ui">
            <div class="hud-top">
                <div class="score-box">
                    <div class="score-num" id="score-disp">0000000</div>
                    <div class="life-gauge"><div class="life-fill" id="life-bar"></div></div>
                </div>
                <button class="btn" style="padding:5px 20px; font-size:0.8rem;" onclick="endGame()">EXIT</button>
            </div>
            
            <div class="combo-box" id="combo-box">
                <div class="combo-val" id="combo-num">0</div>
                <div style="font-weight:bold; letter-spacing:2px;">COMBO</div>
            </div>
            
            <div class="judge-text" id="judge-disp">PERFECT</div>
        </div>
    </div>

    <div id="result-screen" class="screen">
        <div class="panel" style="text-align:center;">
            <h2 style="font-style:italic; margin:0; color:var(--primary)">RESULT</h2>
            <div style="font-size:6rem; font-weight:900; background:linear-gradient(45deg,#fdcb6e,#d63031); -webkit-background-clip:text; -webkit-text-fill-color:transparent;" id="res-rank">S</div>
            <div style="font-size:1.5rem;">Score: <span id="res-score">0</span></div>
            <div style="color:#666;">Max Combo: <span id="res-combo">0</span></div>
            <button class="btn" onclick="navTo('select-screen')">BACK</button>
        </div>
    </div>

<script>
/**
 * SEKAI GEN - Fixed Version
 * - ID3 Album Art Support
 * - Fixed Input/Score Logic
 * - Increased Note Density
 */

const CONFIG = {
    laneCount: 4,
    speed: 9.0,
    difficulty: 2, // 0-4
    inputKeys: ['d', 'f', 'j', 'k'],
    // Âà§ÂÆö„Ç¶„Ç£„É≥„Éâ„Ç¶ (Áßí)
    hitWindow: { perf: 0.06, great: 0.12, good: 0.18, bad: 0.3 }
};

// Èõ£ÊòìÂ∫¶Ë®≠ÂÆöÔºöÂÖ®‰ΩìÁöÑ„Å´ÂØÜÂ∫¶(density)„Çí‰∏ä„Åí„ÄÅÈñæÂÄ§(fluxThr)„Çí‰∏ã„Åí„Çã
const DIFF_SETTINGS = [
    { name: 'EASY',   fluxThr: 1.4, minGap: 0.35, slide: false, doubleChance: 0.0 },
    { name: 'NORMAL', fluxThr: 1.2, minGap: 0.22, slide: false, doubleChance: 0.05 },
    { name: 'HARD',   fluxThr: 1.0, minGap: 0.15, slide: true,  doubleChance: 0.15 },
    { name: 'EXPERT', fluxThr: 0.85, minGap: 0.10, slide: true,  doubleChance: 0.3 }, // High density
    { name: 'MASTER', fluxThr: 0.70, minGap: 0.06, slide: true,  doubleChance: 0.5 }  // Extreme
];

// State
let audioCtx;
let audioBuffer = null;
let chart = [];
let activeNotes = [];
let isPlaying = false;
let score = 0, combo = 0, maxCombo = 0, life = 1000;
let touchLanes = [false, false, false, false];
let bgType = 'none';

// Elements
const mediaSource = document.getElementById('media-source');
const bgImg = document.getElementById('bg-img');
const bgVideo = document.getElementById('bg-video');
const cvs = document.getElementById('game-canvas');
const ctx = cvs.getContext('2d', { alpha: true });

// --- Initialization & UI ---
function navTo(id) {
    document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
    document.getElementById(id).classList.add('active');
    
    if(id === 'title') {
        stopAudio();
    }
}

function setDiff(idx) {
    CONFIG.difficulty = idx;
    document.querySelectorAll('.diff-btn').forEach((b,i) => b.classList.toggle('active', i===idx));
}
function setSpeed(val) {
    CONFIG.speed = parseFloat(val);
    document.getElementById('spd-val').innerText = CONFIG.speed.toFixed(1);
}

// --- File Loading & Analysis ---
async function loadFile(input) {
    const file = input.files[0];
    if(!file) return;
    
    const loading = document.getElementById('loading');
    loading.style.display = 'flex';
    document.getElementById('loading-txt').innerText = "Reading Media...";

    // Reset Backgrounds
    bgImg.style.display = 'none';
    bgVideo.style.display = 'none';

    const objectUrl = URL.createObjectURL(file);
    mediaSource.src = objectUrl;

    // 1. Check for Album Art (ID3) if Audio
    if (file.type.startsWith('audio/')) {
        bgType = 'image';
        
        // Use jsmediatags to extract embedded image
        new jsmediatags.Reader(file).setTagsToRead(["picture"]).read({
            onSuccess: (tag) => {
                const tags = tag.tags;
                if (tags.picture) {
                    const { data, format } = tags.picture;
                    let base64String = "";
                    for (let i = 0; i < data.length; i++) base64String += String.fromCharCode(data[i]);
                    bgImg.src = `data:${format};base64,${window.btoa(base64String)}`;
                    bgImg.style.display = 'block';
                } else {
                    // Fallback visualizer placeholder logic (here just generic bg)
                    bgImg.src = 'https://images.unsplash.com/photo-1470225620780-dba8ba36b745?q=80&w=2070&auto=format&fit=crop';
                    bgImg.style.display = 'block';
                }
            },
            onError: (error) => {
                console.log("No ID3 tags found", error);
                bgImg.src = 'https://images.unsplash.com/photo-1470225620780-dba8ba36b745?q=80&w=2070&auto=format&fit=crop';
                bgImg.style.display = 'block';
            }
        });
    } else if (file.type.startsWith('video/')) {
        bgType = 'video';
        bgVideo.src = objectUrl;
        bgVideo.style.display = 'block';
        // Video element for background needs to be synced with mediaSource or be the same
        // Here we just use mediaSource for audio timing, but we can play bgVideo for visuals
        bgVideo.muted = true;
    }

    // 2. Decode Audio for Charting
    if(!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    
    const arrayBuffer = await file.arrayBuffer();
    try {
        audioBuffer = await audioCtx.decodeAudioData(arrayBuffer);
        
        document.getElementById('loading-txt').innerText = "Generating High-Density Chart...";
        setTimeout(() => {
            generateChart(audioBuffer);
            loading.style.display = 'none';
            document.getElementById('btn-play').innerText = "START GAME";
            document.getElementById('btn-play').disabled = false;
        }, 100);
    } catch(e) {
        alert("Audio Decode Error");
        loading.style.display = 'none';
    }
}

// --- Chart Generation (Enhanced for Density) ---
function generateChart(buffer) {
    const data = buffer.getChannelData(0);
    const sr = buffer.sampleRate;
    const notes = [];
    const diff = DIFF_SETTINGS[CONFIG.difficulty];
    
    // Analysis config
    const hopSize = Math.floor(sr / 60); 
    let localEnergy = [];
    
    // Calculate energy envelope
    for(let k=0; k<data.length; k+=hopSize) {
        let sum = 0;
        // Simple High-pass / Energy
        for(let i=0; i<hopSize && k+i<data.length; i++) {
            let val = Math.abs(data[k+i]);
            sum += val * val;
        }
        localEnergy.push(Math.sqrt(sum/hopSize));
    }

    const lookback = 20;
    let lastTime = -10;
    
    for(let i = lookback; i < localEnergy.length - 10; i++) {
        // Local Average
        let avg = 0; 
        for(let j=1; j<=lookback; j++) avg += localEnergy[i-j];
        avg /= lookback;
        
        let current = localEnergy[i];
        
        // Threshold check (Lower fluxThr = More notes)
        if (current > avg * diff.fluxThr && current > 0.02) {
            let t = (i * hopSize) / sr;
            
            if (t - lastTime >= diff.minGap) {
                
                // --- NOTE GENERATION ---
                let lane = Math.floor(Math.random() * 4);
                
                // Flow check
                if (notes.length > 0) {
                    const prev = notes[notes.length-1];
                    // Prevent jackhammering same lane on easy
                    if(CONFIG.difficulty < 2 && prev.lane === lane) lane = (lane+1)%4;
                }

                let type = 'tap';
                let dur = 0;
                let endLane = lane;

                // Create Long Notes
                if (diff.slide && Math.random() < 0.2) {
                    type = 'long';
                    dur = Math.random() * 0.4 + 0.1; 
                    if (CONFIG.difficulty >= 2 && Math.random() > 0.5) {
                        endLane = Math.floor(Math.random()*4);
                    }
                    lastTime = t + dur * 0.7; // allow slight overlap
                } else {
                    lastTime = t;
                }
                
                notes.push({ time: t, lane, endLane, type, dur, hit: false, processed: false, holding: false });

                // --- DOUBLE NOTE CHANCE (For Difficulty) ---
                if (Math.random() < diff.doubleChance) {
                     let lane2 = (lane + 2) % 4; // Different lane
                     notes.push({ time: t, lane: lane2, endLane: lane2, type: 'tap', dur: 0, hit: false, processed: false });
                }
            }
        }
    }
    
    // Sort notes by time
    chart = notes.sort((a,b) => a.time - b.time);
    console.log(`Generated ${chart.length} notes`);
}

// --- Game Engine ---
function startGame() {
    if(!mediaSource.src) return;
    navTo('game-layer'); // Show canvas
    document.getElementById('game-layer').style.display = 'block';
    document.getElementById('game-ui').style.display = 'flex';
    
    // Stats
    score = 0; combo = 0; maxCombo = 0; life = 1000;
    updateHUD();
    
    activeNotes = JSON.parse(JSON.stringify(chart));
    
    // Audio Start
    mediaSource.currentTime = 0;
    mediaSource.volume = 1.0;
    mediaSource.play();

    if(bgType === 'video') {
        bgVideo.currentTime = 0;
        bgVideo.play();
    }
    
    isPlaying = true;
    resize();
    loop();
}

function stopAudio() {
    mediaSource.pause();
    if(bgType==='video') bgVideo.pause();
    isPlaying = false;
}

function endGame() {
    stopAudio();
    navTo('result-screen');
    
    // Calc Rank
    const maxScore = chart.length * 1000;
    const pct = score / (maxScore || 1);
    let r = 'C';
    if(pct > 0.6) r = 'B';
    if(pct > 0.8) r = 'A';
    if(pct > 0.9) r = 'S';
    if(pct > 0.95) r = 'SS';
    if(pct > 0.98) r = 'ULTIMATE';
    
    document.getElementById('res-rank').innerText = r;
    document.getElementById('res-score').innerText = Math.floor(score);
    document.getElementById('res-combo').innerText = maxCombo;
}

// --- Rendering & Logic Loop ---
function loop() {
    if(!isPlaying) return;
    
    // Check if song ended
    if (mediaSource.ended) {
        endGame();
        return;
    }

    requestAnimationFrame(loop);
    
    // Use Media Element time for sync (The Fix)
    const time = mediaSource.currentTime;
    
    // Clear
    ctx.clearRect(0,0,cvs.width,cvs.height);
    
    drawTrack();
    
    // Draw Notes
    const speed = CONFIG.speed;
    
    // 3D Projection Vars
    // Note: Rendering back-to-front
    
    activeNotes.forEach(n => {
        if(n.processed && n.type !== 'long') return;
        
        // Time Diff
        const dt = n.time - time;
        
        // Miss Logic
        if (!n.hit && !n.processed) {
            // If time passed the bad window
            if (dt < -CONFIG.hitWindow.bad) {
                if(n.type !== 'long' || (n.type==='long' && dt < -(n.dur + CONFIG.hitWindow.bad))) {
                    triggerJudge('MISS');
                    n.processed = true;
                    breakCombo();
                    return;
                }
            }
        }
        
        // Draw Range (Z axis)
        const z = dt * speed;
        if (z > 25 || (z < -5 && n.type !== 'long')) return;
        
        // Draw
        if (n.type === 'long') {
            let endZ = (n.time + n.dur - time) * speed;
            let startZ = z;
            let curLane = n.lane;

            // Handle visual holding
            if (n.holding) {
                startZ = 0;
                // Interpolate lane position
                const p = (time - n.time) / n.dur;
                curLane = n.lane + (n.endLane - n.lane) * Math.min(1, Math.max(0,p));
            }
            
            if(endZ > 0) {
                drawLongNote(curLane, n.endLane, Math.max(0, startZ), endZ);
                if (n.holding) {
                    // Draw Spark
                    const p = project(curLane, 0);
                    ctx.fillStyle = '#fff';
                    ctx.beginPath(); ctx.arc(p.x, p.y, 25, 0, Math.PI*2); ctx.fill();
                }
            }
        } else {
             if (z > -1 && !n.hit) drawNote(n.lane, z, n.type);
        }
    });

    // Auto-complete held long notes
    activeNotes.forEach(n => {
        if (n.holding && !n.processed) {
            if (time >= n.time + n.dur) {
                n.processed = true;
                n.holding = false;
                addScore(500, true);
                triggerJudge('PERFECT');
            }
        }
    });
}

// --- 3D Projection ---
function project(lane, z) {
    const W = cvs.width;
    const H = cvs.height;
    // Perspective
    const fov = 1.0;
    const scale = fov / (fov + z * 0.15);
    
    const horizonY = H * 0.25;
    const hitY = H * 0.85;
    
    const y = horizonY + (hitY - horizonY) * scale;
    
    const baseW = W * 0.6; // Track width at bottom
    const laneW = baseW / 4;
    
    const xOffset = (lane - 1.5) * laneW;
    const x = (W/2) + (xOffset * scale);
    const w = laneW * scale;
    
    return { x, y, w, s: scale };
}

function drawTrack() {
    ctx.lineWidth = 2;
    ctx.strokeStyle = 'rgba(255,255,255,0.3)';
    
    // Lanes
    for(let i=0; i<=4; i++) {
        const p1 = project(i-0.5, 0);
        const p2 = project(i-0.5, 25);
        ctx.beginPath(); ctx.moveTo(p1.x, p1.y); ctx.lineTo(p2.x, p2.y); ctx.stroke();
    }
    
    // Hit Line
    const l = project(-0.5, 0);
    const r = project(3.5, 0);
    ctx.strokeStyle = '#fff';
    ctx.lineWidth = 4;
    ctx.shadowBlur = 10;
    ctx.shadowColor = varColor('--primary');
    ctx.beginPath(); ctx.moveTo(l.x, l.y); ctx.lineTo(r.x, r.y); ctx.stroke();
    ctx.shadowBlur = 0;
    
    // Input Feedback
    touchLanes.forEach((active, i) => {
        if(active) {
            const p = project(i, 0);
            const pFar = project(i, 3);
            ctx.fillStyle = 'rgba(51, 213, 172, 0.4)';
            ctx.beginPath();
            ctx.moveTo(p.x - p.w/2, p.y);
            ctx.lineTo(p.x + p.w/2, p.y);
            ctx.lineTo(pFar.x + pFar.w/2, pFar.y);
            ctx.lineTo(pFar.x - pFar.w/2, pFar.y);
            ctx.fill();
        }
    });
}

function drawNote(lane, z, type) {
    const p = project(lane, z);
    const h = 20 * p.s;
    const w = p.w * 0.9;
    
    ctx.fillStyle = type==='tap'?'#33d5ac':'#ff007c';
    ctx.shadowBlur = 10 * p.s;
    ctx.shadowColor = ctx.fillStyle;
    
    ctx.fillRect(p.x - w/2, p.y - h/2, w, h);
    
    ctx.fillStyle = 'rgba(255,255,255,0.8)';
    ctx.fillRect(p.x - w/2, p.y - h/2, w, h*0.3); // Shine
    ctx.shadowBlur = 0;
}

function drawLongNote(l1, l2, z1, z2) {
    const p1 = project(l1, z1);
    const p2 = project(l2, z2);
    
    ctx.fillStyle = 'rgba(253, 187, 45, 0.6)';
    ctx.strokeStyle = 'rgba(255,255,255,0.5)';
    ctx.lineWidth = 2;
    
    ctx.beginPath();
    ctx.moveTo(p1.x - p1.w/2, p1.y);
    ctx.lineTo(p1.x + p1.w/2, p1.y);
    ctx.lineTo(p2.x + p2.w/2, p2.y);
    ctx.lineTo(p2.x - p2.w/2, p2.y);
    ctx.fill(); ctx.stroke();
}

// --- Input Handling (FIXED) ---
function handleInput(lane) {
    if(!isPlaying) return;
    touchLanes[lane] = true;
    
    const now = mediaSource.currentTime;
    
    // Find the closest unprocessed note in this lane within window
    // Filter first, then sort by proximity
    const candidates = activeNotes.filter(n => 
        !n.processed && 
        n.lane === lane && 
        n.time - now <= CONFIG.hitWindow.bad && // Not too far future
        now - n.time <= CONFIG.hitWindow.bad    // Not too far past
    );
    
    if(candidates.length === 0) return; // No note to hit
    
    // Pick closest
    const note = candidates.reduce((prev, curr) => 
        Math.abs(curr.time - now) < Math.abs(prev.time - now) ? curr : prev
    );

    const diff = Math.abs(note.time - now);
    
    // Judge
    let j = 'MISS', pts = 0;
    if (diff <= CONFIG.hitWindow.perf) { j='PERFECT'; pts=500; }
    else if (diff <= CONFIG.hitWindow.great) { j='GREAT'; pts=300; }
    else if (diff <= CONFIG.hitWindow.good) { j='GOOD'; pts=100; }
    else { j='BAD'; pts=0; }
    
    if (j !== 'BAD') {
        if(note.type === 'long') {
            note.holding = true;
            note.hit = true;
        } else {
            note.processed = true;
            note.hit = true;
        }
        addScore(pts);
        triggerJudge(j);
    } else {
        note.processed = true;
        breakCombo();
        triggerJudge('BAD');
    }
}

function releaseInput(lane) {
    touchLanes[lane] = false;
    const note = activeNotes.find(n => n.holding && n.lane === lane && !n.processed);
    if (note) {
        // If release too early
        if (mediaSource.currentTime < note.time + note.dur - 0.15) {
            note.holding = false;
            note.processed = true;
            breakCombo();
            triggerJudge('MISS');
        }
    }
}

// Helpers
function addScore(pts, isHoldTick=false) {
    if(!isHoldTick) combo++;
    if(combo > maxCombo) maxCombo = combo;
    score += pts * (1 + combo/200);
    updateHUD();
}
function breakCombo() {
    combo = 0;
    life = Math.max(0, life - 40);
    if(life === 0) endGame();
    updateHUD();
}
function updateHUD() {
    document.getElementById('score-disp').innerText = Math.floor(score).toString().padStart(7,'0');
    document.getElementById('life-bar').style.width = (life/10) + '%';
    if(combo > 2) {
        document.getElementById('combo-box').classList.add('show');
        document.getElementById('combo-num').innerText = combo;
    } else {
        document.getElementById('combo-box').classList.remove('show');
    }
}
function triggerJudge(txt) {
    const el = document.getElementById('judge-disp');
    el.innerText = txt;
    el.style.color = txt==='PERFECT'?'#fbc531':(txt==='MISS'?'#666':'#fff');
    el.style.opacity = 1;
    el.style.transform = 'translate(-50%,-50%) scale(1.3)';
    requestAnimationFrame(()=>{
        el.style.transition = '0.1s';
        el.style.transform = 'translate(-50%,-50%) scale(1)';
        setTimeout(()=>el.style.opacity=0, 300);
    });
}
function varColor(name) { return getComputedStyle(document.body).getPropertyValue(name); }

// Event Listeners
window.addEventListener('resize', resize);
function resize() { cvs.width = window.innerWidth; cvs.height = window.innerHeight; }

// Keyboard
window.addEventListener('keydown', e => {
    if(e.repeat) return;
    const idx = CONFIG.inputKeys.indexOf(e.key.toLowerCase());
    if(idx>=0) handleInput(idx);
});
window.addEventListener('keyup', e => {
    const idx = CONFIG.inputKeys.indexOf(e.key.toLowerCase());
    if(idx>=0) releaseInput(idx);
});

// Touch (Column based)
cvs.addEventListener('touchstart', e => {
    e.preventDefault();
    for(let i=0; i<e.changedTouches.length; i++) {
        const t = e.changedTouches[i];
        const lane = Math.floor(t.clientX / (window.innerWidth/4));
        handleInput(lane);
    }
}, {passive:false});
cvs.addEventListener('touchend', e => {
    e.preventDefault();
    for(let i=0; i<e.changedTouches.length; i++) {
        const t = e.changedTouches[i];
        const lane = Math.floor(t.clientX / (window.innerWidth/4));
        releaseInput(lane);
    }
});

</script>
</body>
</html>
