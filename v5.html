<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>SEKAI GEN - Ultimate AI Rhythm</title>
    <style>
        /* --- CSS Variables & Reset --- */
        :root {
            --primary: #33d5ac; /* Miku Green */
            --primary-dark: #209c7d;
            --accent: #ff007c; /* Flick Pink */
            --long: #fdbb2d;   /* Long Yellow */
            --bg: #000;
            --font-main: 'Helvetica Neue', Arial, sans-serif;
        }
        * { box-sizing: border-box; touch-action: none; user-select: none; -webkit-user-select: none; }
        body { margin: 0; overflow: hidden; background: #000; font-family: var(--font-main); color: white; }

        /* --- Background Video Layer --- */
        #bg-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            z-index: -1; overflow: hidden;
        }
        #bg-video {
            width: 100%; height: 100%; object-fit: cover; opacity: 0.6;
            filter: blur(2px) brightness(0.8); transition: filter 0.5s;
        }
        /* When playing, brighten up */
        body.playing #bg-video { filter: blur(0px) brightness(1.0); opacity: 0.8; }

        /* --- UI Layers --- */
        .screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            transition: opacity 0.5s; opacity: 0; pointer-events: none; z-index: 10;
        }
        .screen.active { opacity: 1; pointer-events: auto; }

        /* --- Title Screen --- */
        #title-screen { background: rgba(0,0,0,0.7); }
        .logo-img { max-width: 80%; width: 400px; margin-bottom: 20px; filter: drop-shadow(0 0 20px var(--primary)); animation: float 3s ease-in-out infinite; }
        @keyframes float { 0%, 100% { transform: translateY(0); } 50% { transform: translateY(-10px); } }

        .btn-start {
            font-size: 1.5rem; padding: 15px 60px; 
            background: linear-gradient(135deg, var(--primary), #3dd);
            border: none; border-radius: 50px; color: white; font-weight: bold; cursor: pointer;
            box-shadow: 0 5px 25px rgba(51, 213, 172, 0.6); 
            text-transform: uppercase; letter-spacing: 2px; transition: transform 0.1s;
        }
        .btn-start:active { transform: scale(0.95); }

        /* --- Selection Screen --- */
        #select-screen { background: rgba(0,0,0,0.8); backdrop-filter: blur(10px); }
        .panel {
            background: rgba(255, 255, 255, 0.95); color: #333;
            width: 90%; max-width: 700px; padding: 30px; border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.8); display: flex; flex-direction: column; gap: 20px;
            max-height: 90vh; overflow-y: auto;
        }
        .section-title { color: var(--primary-dark); font-weight: 800; border-bottom: 3px solid #eee; margin-bottom: 10px; font-size: 1.2rem; }
        
        .file-drop {
            border: 3px dashed #bbb; padding: 40px; text-align: center; border-radius: 15px;
            cursor: pointer; transition: 0.3s; background: #f9f9f9;
        }
        .file-drop:hover { border-color: var(--primary); background: #e0fbf4; transform: translateY(-2px); }
        
        /* Diff Buttons */
        .diff-selector { display: flex; gap: 5px; width: 100%; margin-top: 10px; }
        .diff-btn {
            flex: 1; padding: 15px 0; border: none; color: white; font-weight: 900; font-size: 0.9rem;
            cursor: pointer; opacity: 0.3; transition: all 0.2s; border-radius: 8px; text-align: center;
            transform: skewX(-10deg); position: relative; overflow: hidden;
        }
        .diff-btn span { display: block; transform: skewX(10deg); z-index: 2; position: relative; }
        .diff-btn::after { content:''; position: absolute; top:0; left:0; width:100%; height:100%; background:linear-gradient(rgba(255,255,255,0.3), transparent); }
        .diff-btn.selected { opacity: 1; transform: skewX(-10deg) scale(1.05); box-shadow: 0 5px 20px rgba(0,0,0,0.4); z-index: 5; }
        
        .diff-easy { background: #69f0ae; }
        .diff-normal { background: #40c4ff; }
        .diff-hard { background: #ffab40; }
        .diff-expert { background: #ff5252; }
        .diff-master { background: #7c4dff; }

        /* --- Game Screen --- */
        #game-screen { pointer-events: none; } /* Canvas handles input */
        #game-canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: block; z-index: 1; }
        
        .game-ui {
            position: absolute; width: 100%; height: 100%; pointer-events: none; z-index: 5;
            display: flex; flex-direction: column; justify-content: space-between; padding: 20px;
        }
        .top-bar { display: flex; justify-content: space-between; align-items: flex-start; text-shadow: 0 2px 5px rgba(0,0,0,0.8); }
        .life-frame { 
            width: 300px; height: 15px; background: rgba(0,0,0,0.5); 
            border: 2px solid rgba(255,255,255,0.3); border-radius: 10px; overflow: hidden; 
            margin-top: 5px; position: relative;
        }
        .life-bar { height: 100%; background: linear-gradient(90deg, #69f0ae, #00e676); width: 100%; transition: width 0.1s; box-shadow: 0 0 15px #69f0ae; }
        .score-display { font-size: 2.2rem; font-family: 'Courier New', monospace; font-weight: 900; letter-spacing: -1px; }
        
        .combo-display {
            position: absolute; top: 40%; left: 50%; transform: translate(-50%, -50%);
            text-align: center; opacity: 0; transition: transform 0.1s;
        }
        .combo-display.show { opacity: 1; }
        .combo-num { 
            font-size: 6rem; font-weight: 900; font-style: italic; line-height: 1;
            background: linear-gradient(to bottom, #fff 40%, var(--primary)); 
            -webkit-background-clip: text; -webkit-text-fill-color: transparent;
            filter: drop-shadow(0 0 10px rgba(51, 213, 172, 0.5));
        }
        .combo-text { font-size: 1.2rem; font-weight: 800; letter-spacing: 5px; margin-left: 5px; color: white; }
        
        .judge-display {
            position: absolute; top: 60%; left: 50%; transform: translate(-50%, -50%);
            font-size: 3rem; font-weight: 900; font-style: italic;
            text-shadow: 0 0 20px rgba(255,255,255,0.8); opacity: 0;
        }

        .btn-back { pointer-events: auto; background: rgba(0,0,0,0.6); color: white; border: 1px solid white; padding: 5px 15px; border-radius: 20px; cursor: pointer; }

        /* --- Result Screen --- */
        #result-screen { background: rgba(0,0,0,0.85); backdrop-filter: blur(10px); }
        .result-card {
            background: white; color: #333; padding: 40px; border-radius: 30px;
            text-align: center; box-shadow: 0 0 50px rgba(51, 213, 172, 0.4);
            animation: popIn 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275); min-width: 300px;
        }
        @keyframes popIn { from { transform: scale(0.8); opacity: 0; } to { transform: scale(1); opacity: 1; } }

        /* --- Loading --- */
        #loading-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9);
            z-index: 100; display: none; flex-direction: column; align-items: center; justify-content: center; color: white;
        }
        .spinner {
            width: 50px; height: 50px; border: 5px solid rgba(255,255,255,0.1);
            border-top: 5px solid var(--primary); border-radius: 50%; animation: spin 0.8s linear infinite; margin-bottom: 20px;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    </style>
</head>
<body>

    <div id="bg-layer">
        <video id="bg-video" playsinline webkit-playsinline></video>
    </div>

    <div id="loading-overlay">
        <div class="spinner"></div>
        <div id="loading-text">Analyzing Audio Spectrum...</div>
    </div>

    <div id="title-screen" class="screen active">
        <img src="https://regeld.com/desi/wp-content/uploads/2021/02/210207_music11.png" alt="Logo" class="logo-img">
        <p style="opacity: 0.8; letter-spacing: 1px; margin-bottom: 30px;">AI GENERATED RHYTHM GAME</p>
        <button class="btn-start" onclick="navTo('select-screen')">TAP TO START</button>
    </div>

    <div id="select-screen" class="screen">
        <div class="panel">
            <h2 style="margin:0; text-align: center; color:var(--primary); text-transform:uppercase;">Music Select</h2>
            
            <div>
                <div class="section-title">MEDIA FILE</div>
                <div class="file-drop" onclick="document.getElementById('file-input').click()">
                    <span style="font-size: 1.2rem; font-weight: bold; color: #555;">üìÇ „Çø„ÉÉ„Éó„Åó„Å¶„Éï„Ç°„Ç§„É´„ÇíÈÅ∏Êäû</span><br>
                    <small style="color:#888;">(MP3, WAV, MP4, MOV ÂØæÂøú)<br>ÂãïÁîª„Éï„Ç°„Ç§„É´„ÅØËÉåÊôØ„ÅßÂÜçÁîü„Åï„Çå„Åæ„Åô</small>
                </div>
                <input type="file" id="file-input" accept="audio/*,video/*" style="display: none;" onchange="handleFileSelect(this)">
            </div>

            <div>
                <div class="section-title">DIFFICULTY & SPEED</div>
                <div class="diff-selector">
                    <button class="diff-btn diff-easy" onclick="setDiff(0)"><span>EASY</span></button>
                    <button class="diff-btn diff-normal" onclick="setDiff(1)"><span>NORMAL</span></button>
                    <button class="diff-btn diff-hard selected" onclick="setDiff(2)"><span>HARD</span></button>
                    <button class="diff-btn diff-expert" onclick="setDiff(3)"><span>EXPERT</span></button>
                    <button class="diff-btn diff-master" onclick="setDiff(4)"><span>MASTER</span></button>
                </div>
                
                <div style="margin-top:20px;">
                    <label style="font-weight:bold; color:#555;">„Éé„Éº„ÉÑ„Çπ„Éî„Éº„Éâ: <span id="speed-val" style="color:var(--primary);">9.0</span></label>
                    <input type="range" min="1" max="15" step="0.1" value="9" style="width:100%; accent-color:var(--primary);" oninput="updateSpeed(this.value)">
                </div>
            </div>

            <button class="btn-start" style="width:100%; margin-top:10px;" onclick="startGame()" id="btn-play" disabled>FILE REQUIRED</button>
        </div>
    </div>

    <div id="game-screen" class="screen">
        <canvas id="game-canvas"></canvas>
        <div class="game-ui">
            <div class="top-bar">
                <div>
                    <div class="score-display" id="score">0000000</div>
                    <div class="life-frame"><div class="life-bar" id="life-bar"></div></div>
                </div>
                <button class="btn-back" onclick="quitGame()">PAUSE</button>
            </div>
            
            <div class="combo-display" id="combo-container">
                <span class="combo-num" id="combo-num">0</span><br>
                <span class="combo-text">COMBO</span>
            </div>
            
            <div class="judge-display" id="judge-text">PERFECT</div>
        </div>
    </div>

    <div id="result-screen" class="screen">
        <div class="result-card">
            <h2 style="font-style:italic; margin:0; color:var(--primary)">FINISH</h2>
            <div style="font-size: 6rem; font-weight:900; background: linear-gradient(45deg, #ffeb3b, #ff9800); -webkit-background-clip:text; -webkit-text-fill-color:transparent;" id="result-rank">S</div>
            <div style="font-size:1.5rem; font-weight:bold;">Score: <span id="result-score">0</span></div>
            <div style="font-size:1.2rem; color:#666;">Max Combo: <span id="result-combo">0</span></div>
            <button class="btn-start" style="margin-top:20px; font-size:1rem; padding:10px 40px;" onclick="navTo('select-screen')">BACK</button>
        </div>
    </div>

<script>
/**
 * SEKAI GEN - Ultimate Logic (Reverted Version)
 * Features:
 * - Deterministic "Local Energy" Peak Detection (Better than RMS threshold)
 * - 3D Perspective Rendering with Polygon Tesselation for Long Notes
 * - Video Background Sync
 */

// --- Global State ---
const state = {
    screen: 'title',
    audioCtx: null,
    analyzeBuffer: null, // For analysis
    videoEl: document.getElementById('bg-video'),
    isPlaying: false,
    difficulty: 2, 
    noteSpeed: 9.0,
    chart: [], 
    score: 0,
    combo: 0,
    maxCombo: 0,
    life: 1000,
    activeNotes: [],
    laneCount: 4, 
    keyMapping: ['d', 'f', 'j', 'k'], 
    touchLanes: [false, false, false, false],
    holdLanes: [false, false, false, false], // Track active holds
    videoDuration: 0
};

const DIFFICULTY_CONFIG = [
    { name: 'EASY',   density: 0.6, sensitivity: 1.4, allowSlide: false },
    { name: 'NORMAL', density: 1.0, sensitivity: 1.3, allowSlide: false },
    { name: 'HARD',   density: 1.8, sensitivity: 1.2, allowSlide: true },
    { name: 'EXPERT', density: 3.5, sensitivity: 1.1, allowSlide: true },
    { name: 'MASTER', density: 6.0, sensitivity: 1.05, allowSlide: true }
];

// Constants
const HIT_WINDOW = { PERFECT: 0.050, GREAT: 0.090, GOOD: 0.150, BAD: 0.250 };
const CANVAS = document.getElementById('game-canvas');
const CTX = CANVAS.getContext('2d', { alpha: true });

// 3D Perspective Setup
const PERSPECTIVE = {
    fov: 1.2,
    cameraY: 3.5,
    cameraZ: -1.0,
    horizonY: 0.2, // Screen percent
    baseWidth: 0.6 // Track width at bottom
};

// --- Navigation ---
function navTo(screenId) {
    document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
    document.getElementById(screenId).classList.add('active');
    state.screen = screenId;
    if (screenId === 'title') {
        state.videoEl.pause();
        state.videoEl.style.display = 'none';
        document.body.classList.remove('playing');
    }
}

function updateSpeed(val) {
    state.noteSpeed = parseFloat(val);
    document.getElementById('speed-val').textContent = state.noteSpeed.toFixed(1);
}

function setDiff(idx) {
    state.difficulty = idx;
    document.querySelectorAll('.diff-btn').forEach((b, i) => {
        b.classList.toggle('selected', i === idx);
    });
}

function stopGame() {
    state.videoEl.pause();
    state.isPlaying = false;
    document.body.classList.remove('playing');
}

// --- Audio & File Handling ---

function initAudio() {
    if (!state.audioCtx) {
        state.audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    }
}

async function handleFileSelect(input) {
    const file = input.files[0];
    if (!file) return;

    document.getElementById('btn-play').innerText = "ANALYZING...";
    document.getElementById('loading-overlay').style.display = 'flex';
    
    initAudio();

    // Set video source for playback
    const fileURL = URL.createObjectURL(file);
    state.videoEl.src = fileURL;
    state.videoEl.style.display = 'block';

    // Decode audio for chart analysis
    const reader = new FileReader();
    reader.onload = async (e) => {
        try {
            const arrayBuffer = e.target.result;
            // Decode complete file for accurate chart generation
            state.analyzeBuffer = await state.audioCtx.decodeAudioData(arrayBuffer);
            state.videoDuration = state.analyzeBuffer.duration;
            
            generateChartHighPerformance(state.analyzeBuffer, file.name);
            
            document.getElementById('loading-overlay').style.display = 'none';
            document.getElementById('btn-play').innerText = "GAME START";
            document.getElementById('btn-play').disabled = false;
        } catch (err) {
            console.error(err);
            alert("Ëß£Êûê„Ç®„É©„Éº: Èü≥Â£∞„Éá„Éº„Çø„ÅåÂê´„Åæ„Çå„Å¶„ÅÑ„Å™„ÅÑ„Åã„ÄÅÂΩ¢Âºè„ÅåÈùûÂØæÂøú„Åß„Åô„ÄÇ");
            document.getElementById('loading-overlay').style.display = 'none';
        }
    };
    reader.readAsArrayBuffer(file);
}

// --- "High Performance" Chart Generation Algorithm ---
// Uses Local Energy vs Global Average to detect Onsets (Beats)
function generateChartHighPerformance(buffer, seedString) {
    const channelData = buffer.getChannelData(0);
    const sampleRate = buffer.sampleRate;
    const notes = [];
    
    const conf = DIFFICULTY_CONFIG[state.difficulty];
    
    // Config: How many samples to average for "Local Energy"
    const windowSize = 1024; 
    const step = Math.floor(sampleRate / 60); // Check 60 times a sec
    
    // Pseudo Random seeded
    let seedVal = 0;
    for(let i=0; i<seedString.length; i++) seedVal += seedString.charCodeAt(i);
    const random = () => {
        seedVal = (seedVal * 9301 + 49297) % 233280;
        return seedVal / 233280;
    };

    let localEnergies = [];
    // 1. Calculate Energy Map
    for (let i = 0; i < channelData.length; i += step) {
        let sum = 0;
        // Simple RMS
        for(let j=0; j<step && i+j<channelData.length; j++) {
            sum += channelData[i+j] * channelData[i+j];
        }
        localEnergies.push(Math.sqrt(sum / step));
    }

    // 2. Peak Picking
    // Moving average logic to determine dynamic threshold
    const historySize = 40; // Look at ~0.7s history
    let lastNoteTime = -10;

    // Minimum gap depends on difficulty density
    const minGap = 1.0 / (conf.density * 2); 

    for (let i = historySize; i < localEnergies.length; i++) {
        // Calculate local average of previous frames
        let avg = 0;
        for(let h=1; h<=historySize; h++) avg += localEnergies[i-h];
        avg /= historySize;

        const currentE = localEnergies[i];
        
        // Threshold: Peak must be X times stronger than background
        // Harder difficulty = Lower threshold (detects subtle beats)
        if (currentE > avg * conf.sensitivity && currentE > 0.05) {
            const time = (i * step) / sampleRate;
            
            if (time - lastNoteTime >= minGap) {
                // Determine Lane & Type
                const r = random();
                let lane = Math.floor(random() * state.laneCount);
                
                // Ensure variety but not too chaotic for easier diffs
                if (Math.abs(lane - (notes.length > 0 ? notes[notes.length-1].lane : 0)) > 2 && conf.density < 2) {
                    lane = 1; // Center bias for easy
                }

                let type = 'tap';
                let duration = 0;
                let endLane = lane;

                // Long Note Logic
                if (r < 0.20 || (conf.density < 1.0 && r < 0.3)) { // More long notes in general
                    type = 'long';
                    duration = 0.5 + (random() * 1.5); // 0.5s - 2.0s
                    
                    // Slide Logic (Bending Long Notes)
                    if (conf.allowSlide && random() > 0.4) {
                        // Slide to adjacent lane or 2 lanes away
                        const shift = Math.floor(random() * 3) - 1; // -1, 0, 1
                        endLane = Math.max(0, Math.min(3, lane + (random() > 0.5 ? 1 : -1) * (random()>0.8?2:1)));
                    } else {
                        endLane = lane;
                    }

                    // Ensure we don't overlap next note start
                    lastNoteTime = time + duration * 0.8; 
                } else if (r > 0.85 && conf.density > 2) {
                    type = 'flick';
                    lastNoteTime = time;
                } else {
                    lastNoteTime = time;
                }

                notes.push({
                    time: time,
                    lane: lane,
                    endLane: endLane, // For slides
                    type: type,
                    duration: duration,
                    hit: false,
                    processed: false,
                    holding: false
                });
            }
        }
    }
    
    state.chart = notes;
    console.log(`Generated ${notes.length} notes. Difficulty: ${conf.name}`);
}

// --- Game Loop ---

function startGame() {
    navTo('game-screen');
    state.score = 0;
    state.combo = 0;
    state.maxCombo = 0;
    state.life = 1000;
    state.holdLanes = [false, false, false, false];
    state.activeNotes = JSON.parse(JSON.stringify(state.chart));
    
    updateLifeUI();
    updateScoreUI();
    document.getElementById('combo-container').classList.remove('show');
    document.body.classList.add('playing');

    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);

    // Sync Audio & Video
    state.videoEl.currentTime = 0;
    state.videoEl.volume = 1.0;
    
    // Start delay
    setTimeout(() => {
        state.videoEl.play();
        state.isPlaying = true;
        gameLoop();
    }, 1000);
}

function quitGame() {
    stopGame();
    navTo('select-screen');
}

function showResult() {
    stopGame();
    navTo('result-screen');
    document.getElementById('result-score').innerText = Math.floor(state.score);
    document.getElementById('result-combo').innerText = state.maxCombo;
    
    let rank = 'C';
    const maxPossible = state.chart.length * 1000; // rough estimate
    const pct = state.score / maxPossible;
    if(pct > 0.6) rank = 'B';
    if(pct > 0.8) rank = 'A';
    if(pct > 0.9) rank = 'S';
    if(pct > 0.95) rank = 'SS';
    if(pct > 0.98) rank = 'MASTER';
    
    document.getElementById('result-rank').innerText = rank;
}

function resizeCanvas() {
    CANVAS.width = window.innerWidth;
    CANVAS.height = window.innerHeight;
}

// --- 3D Projection Engine ---
function project(lane, z) {
    const w = CANVAS.width;
    const h = CANVAS.height;
    
    // Perspective math
    // z = 0 is hit line. z increases into distance.
    const fov = 1.0;
    const scale = fov / (fov + z * 0.5); // Depth scale
    
    const horizonY = h * 0.2;
    const hitY = h * 0.85;
    
    // Y Position
    const y = horizonY + (hitY - horizonY) * scale;
    
    // X Position
    // Map lane (-1.5 to 1.5) to screen X
    // Track is wider at bottom, narrow at top
    const trackWidthAtHit = w * (window.innerWidth < 600 ? 1.0 : 0.5);
    const laneWidthAtHit = trackWidthAtHit / 4;
    const centerX = w / 2;
    
    const laneOffset = (lane - 1.5) * laneWidthAtHit;
    const x = centerX + (laneOffset * scale);
    const width = laneWidthAtHit * scale;
    
    return { x, y, w: width, s: scale };
}

// --- Main Render Loop ---
function gameLoop() {
    if (!state.isPlaying) return;
    if (state.videoEl.ended) { showResult(); return; }

    // Clear Canvas (Transparent to show video)
    CTX.clearRect(0, 0, CANVAS.width, CANVAS.height);
    
    // Semi-transparent overlay to make notes pop against video
    CTX.fillStyle = 'rgba(0, 0, 0, 0.4)';
    CTX.fillRect(0, 0, CANVAS.width, CANVAS.height);

    const currentTime = state.videoEl.currentTime;

    drawTrack();
    drawJudgeLine();

    // Render Notes
    // Draw from far to near (painter's algorithm) to handle overlapping
    // Sort logic is implicit if we iterate well, but generally:
    // Long Note Bodies first, then Note Heads.
    
    // 1. Draw Long Note Bodies (Trails)
    state.activeNotes.forEach(note => {
        if(note.processed && note.type !== 'long') return;
        if(note.type !== 'long') return; // Skip normal notes here
        
        const timeDiff = note.time - currentTime;
        const endDiff = (note.time + note.duration) - currentTime;
        
        if (endDiff < -0.2) return; // Gone
        if (timeDiff > 4.0) return; // Too far

        // Calculate Z positions
        // If holding, the head is stuck at Z=0 (Hit line)
        let zHead = timeDiff * state.noteSpeed;
        let headLane = note.lane;
        
        if (note.holding) {
            zHead = 0; // Visual lock
            // Interpolate current lane based on hold progress for visual slide
            const progress = (currentTime - note.time) / note.duration;
            headLane = note.lane + (note.endLane - note.lane) * progress;
        }

        const zTail = endDiff * state.noteSpeed;
        
        if (zTail < 0) return; // Fully passed

        // Draw Polygon
        const pHead = project(headLane, Math.max(0, zHead));
        const pTail = project(note.endLane, zTail); // Tail is at endLane

        CTX.fillStyle = 'rgba(253, 187, 45, 0.6)'; // Long Yellow
        CTX.strokeStyle = 'rgba(255, 255, 255, 0.5)';
        CTX.lineWidth = 2 * pTail.s;
        
        CTX.beginPath();
        // Quad points
        CTX.moveTo(pHead.x - pHead.w/2 + 2, pHead.y); // BL
        CTX.lineTo(pHead.x + pHead.w/2 - 2, pHead.y); // BR
        CTX.lineTo(pTail.x + pTail.w/2 - 2, pTail.y); // TR
        CTX.lineTo(pTail.x - pTail.w/2 + 2, pTail.y); // TL
        CTX.fill();
        CTX.stroke();

        // If holding, draw a "spark" at the hit line
        if(note.holding) {
            CTX.fillStyle = '#fff';
            CTX.globalCompositeOperation = 'add';
            CTX.beginPath();
            CTX.arc(pHead.x, pHead.y, 20, 0, Math.PI*2);
            CTX.fill();
            CTX.globalCompositeOperation = 'source-over';
        }
    });

    // 2. Draw Note Heads (Taps, Flicks, Starts of Longs)
    state.activeNotes.forEach(note => {
        if (note.holding) return; // Head is "consumed" if holding
        if (note.processed) return;

        const timeDiff = note.time - currentTime;
        if (timeDiff < -0.2 || timeDiff > 4.0) return;
        
        const z = timeDiff * state.noteSpeed;
        const p = project(note.lane, z);
        
        if (p.s < 0.1) return; // Too far

        drawNoteHead(p, note.type);
    });

    requestAnimationFrame(gameLoop);
}

function drawTrack() {
    CTX.strokeStyle = 'rgba(255, 255, 255, 0.3)';
    CTX.lineWidth = 2;
    CTX.beginPath();
    
    // Draw 5 lines
    for(let i=0; i<=4; i++) {
        // Lane boundary
        // Lane 0 is between i=0 and i=1
        const laneVal = i - 0.5; // Boundary logic
        // Manual project for line
        // We calculate position at z=0 and z=20
        const pNear = project(laneVal - 1.5, 0); // Hacky offset to match lanes
        const pFar = project(laneVal - 1.5, 20);
        
        CTX.moveTo(pNear.x, pNear.y);
        CTX.lineTo(pFar.x, pFar.y);
    }
    CTX.stroke();
}

function drawJudgeLine() {
    const pLeft = project(-0.5, 0);
    const pRight = project(3.5, 0);
    
    CTX.strokeStyle = 'white';
    CTX.lineWidth = 3;
    CTX.shadowBlur = 10;
    CTX.shadowColor = varPrimary();
    CTX.beginPath();
    CTX.moveTo(pLeft.x - pLeft.w/2, pLeft.y);
    CTX.lineTo(pRight.x + pRight.w/2, pRight.y);
    CTX.stroke();
    CTX.shadowBlur = 0;

    // Key Feedback
    state.touchLanes.forEach((pressed, i) => {
        if(pressed) {
            const p = project(i, 0);
            const grad = CTX.createLinearGradient(0, p.y - 100, 0, p.y);
            grad.addColorStop(0, 'rgba(51, 213, 172, 0)');
            grad.addColorStop(1, 'rgba(51, 213, 172, 0.4)');
            CTX.fillStyle = grad;
            CTX.fillRect(p.x - p.w/2, p.y - 150, p.w, 150);
        }
    });
}

function drawNoteHead(p, type) {
    const h = 20 * p.s;
    const w = p.w * 0.95;
    const x = p.x - w/2;
    const y = p.y - h/2;

    CTX.shadowBlur = 10 * p.s;
    let color = '#33d5ac';
    if(type === 'flick') color = '#ff007c';
    if(type === 'long') color = '#fdbb2d';
    
    CTX.fillStyle = color;
    CTX.shadowColor = color;
    
    // Simple Rect for performance + clarity
    CTX.beginPath();
    CTX.roundRect(x, y, w, h, 3);
    CTX.fill();
    
    // Highlight
    CTX.fillStyle = 'rgba(255,255,255,0.7)';
    CTX.shadowBlur = 0;
    CTX.fillRect(x + w*0.1, y + h*0.2, w*0.8, h*0.3);

    if(type === 'flick') {
        CTX.strokeStyle = '#fff';
        CTX.lineWidth = 3 * p.s;
        CTX.beginPath();
        CTX.moveTo(p.x - w*0.3, p.y + h);
        CTX.lineTo(p.x, p.y - h);
        CTX.lineTo(p.x + w*0.3, p.y + h);
        CTX.stroke();
    }
}

// --- Input & Judgement ---
function handleInput(lane, type='tap') {
    if (!state.isPlaying) return;
    state.touchLanes[lane] = true;
    
    const now = state.videoEl.currentTime;

    // Check for notes in this lane
    const note = state.activeNotes.find(n => 
        !n.processed && 
        n.lane === lane && 
        Math.abs(n.time - now) < HIT_WINDOW.BAD
    );

    if (note) {
        // Hit Logic
        const diff = Math.abs(note.time - now);
        let judge = 'MISS';
        let pts = 0;
        
        if (diff < HIT_WINDOW.PERFECT) { judge = 'PERFECT'; pts = 500; }
        else if (diff < HIT_WINDOW.GREAT) { judge = 'GREAT'; pts = 300; }
        else if (diff < HIT_WINDOW.GOOD) { judge = 'GOOD'; pts = 100; }
        else { judge = 'BAD'; pts = 0; }
        
        if (judge !== 'BAD') {
            triggerJudge(judge);
            state.combo++;
            if(state.combo > state.maxCombo) state.maxCombo = state.combo;
            state.score += pts * (1 + state.combo/100);
            
            if (note.type === 'long') {
                note.holding = true;
                state.holdLanes[lane] = true;
            } else {
                note.processed = true;
                note.hit = true;
            }
        } else {
            breakCombo();
        }
        updateScoreUI();
    }
}

function releaseInput(lane) {
    state.touchLanes[lane] = false;
    
    // Check if we were holding a long note
    // Find active hold in this lane
    const holdNote = state.activeNotes.find(n => n.holding && !n.processed);
    
    if (holdNote) {
        // If released too early? 
        // For simplicity: if released close to end time, count as processed.
        // If released way too early, MISS.
        const now = state.videoEl.currentTime;
        const endTime = holdNote.time + holdNote.duration;
        
        if (Math.abs(endTime - now) < 0.5) { // Lenient release
             holdNote.processed = true;
             triggerJudge('PERFECT'); // Release bonus
             state.score += 200;
        } else {
             breakCombo();
             holdNote.processed = true; // Kill the note
             triggerJudge('MISS');
        }
        holdNote.holding = false;
    }
}

// Maintain holds
setInterval(() => {
    if(!state.isPlaying) return;
    const now = state.videoEl.currentTime;
    
    state.activeNotes.forEach(n => {
        if (n.holding && !n.processed) {
            // Check if finished
            if (now >= n.time + n.duration) {
                n.processed = true;
                n.holding = false;
                state.score += 500; // Finish bonus
                updateScoreUI();
                triggerJudge('PERFECT');
            }
        }
    });
}, 50);

function breakCombo() {
    state.combo = 0;
    state.life = Math.max(0, state.life - 50);
    updateLifeUI();
    document.getElementById('combo-container').classList.remove('show');
}

function triggerJudge(text) {
    const el = document.getElementById('judge-text');
    el.innerText = text;
    el.style.color = (text === 'PERFECT') ? '#ffeb3b' : (text==='MISS'?'#888':'#fff');
    el.style.opacity = 1;
    el.style.transform = 'translate(-50%, -50%) scale(1.2)';
    requestAnimationFrame(() => {
        el.style.transition = '0.1s';
        setTimeout(() => el.style.opacity = 0, 300);
    });
    
    if(state.combo > 1) {
        document.getElementById('combo-container').classList.add('show');
        document.getElementById('combo-num').innerText = state.combo;
    }
}

function updateScoreUI() {
    document.getElementById('score').innerText = Math.floor(state.score).toString().padStart(7, '0');
}
function updateLifeUI() {
    document.getElementById('life-bar').style.width = (state.life/10) + '%';
}
function varPrimary() { return getComputedStyle(document.documentElement).getPropertyValue('--primary'); }

// --- Event Listeners ---
window.addEventListener('keydown', e => {
    if(e.repeat) return;
    const k = state.keyMapping.indexOf(e.key.toLowerCase());
    if(k!==-1) handleInput(k);
});
window.addEventListener('keyup', e => {
    const k = state.keyMapping.indexOf(e.key.toLowerCase());
    if(k!==-1) releaseInput(k);
});

// Touch (Simple mapping)
CANVAS.addEventListener('touchstart', e => {
    e.preventDefault();
    for(let i=0; i<e.changedTouches.length; i++) {
        const x = e.changedTouches[i].clientX;
        const lane = Math.floor(x / (window.innerWidth/4));
        handleInput(lane);
    }
}, {passive:false});

CANVAS.addEventListener('touchend', e => {
    e.preventDefault();
    for(let i=0; i<e.changedTouches.length; i++) {
        const x = e.changedTouches[i].clientX;
        const lane = Math.floor(x / (window.innerWidth/4));
        releaseInput(lane);
    }
});

</script>
</body>
</html>
