<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>Holo Rhythm Game</title>
<style>
    body { margin: 0; overflow: hidden; background: #000; font-family: 'Segoe UI', sans-serif; color: white; user-select: none; -webkit-user-select: none; }
    #background-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 0; pointer-events: none; }
    #yt-player-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; opacity: 0.6; }
    #visualizer-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: linear-gradient(to bottom, rgba(0,0,0,0.3) 0%, rgba(0,0,0,0.8) 100%); }
    canvas { position: absolute; top: 0; left: 0; z-index: 10; touch-action: none; }
    
    .screen-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 20; pointer-events: none; }
    .screen { position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: flex; align-items: center; justify-content: center; background: rgba(0,0,0,0.85); pointer-events: auto; transition: opacity 0.3s; }
    .hidden { display: none !important; opacity: 0; pointer-events: none; }
    
    .screen-content { text-align: center; width: 90%; max-width: 600px; }
    .title-logo { max-width: 80%; height: auto; margin-bottom: 20px; }
    h1 { margin: 0; font-size: 2.5rem; color: #39c5bb; text-shadow: 0 0 10px rgba(57,197,187,0.5); }
    
    .btn { background: #39c5bb; color: #000; border: none; padding: 15px 30px; font-size: 1.2rem; font-weight: bold; margin: 10px; cursor: pointer; border-radius: 30px; transition: transform 0.1s, background 0.2s; text-decoration: none; display: inline-block; }
    .btn:active { transform: scale(0.95); }
    .btn:disabled { background: #555; color: #888; cursor: not-allowed; }
    .btn-collab { background: #ff0055; color: white; }
    .btn-footer { font-size: 0.9rem; padding: 8px 16px; background: transparent; border: 1px solid #555; color: #aaa; }
    
    #song-select-area { display: grid; grid-template-columns: 1fr; gap: 15px; background: rgba(0,0,0,0.5); padding: 20px; border-radius: 15px; border: 1px solid #333; max-height: 70vh; overflow-y: auto; pointer-events: auto; }
    #song-list-scroll { max-height: 200px; overflow-y: auto; border: 1px solid #444; background: rgba(0,0,0,0.3); margin-top: 5px; }
    .song-item { padding: 10px; border-bottom: 1px solid #444; cursor: pointer; text-align: left; }
    .song-item:hover { background: rgba(255,255,255,0.1); }
    .song-item.selected { background: #39c5bb; color: #000; }
    
    .hud-element { position: absolute; z-index: 15; pointer-events: none; font-weight: bold; text-shadow: 1px 1px 2px black; }
    #life-container { top: 10px; left: 10px; width: 300px; height: 20px; background: #333; border: 2px solid #fff; border-radius: 10px; overflow: hidden; }
    #life-bar { width: 100%; height: 100%; background: #4caf50; transition: width 0.1s; }
    #score-display { top: 10px; right: 10px; font-size: 1.5rem; }
    #combo-container { top: 30%; left: 50%; transform: translate(-50%, -50%); text-align: center; display: none; }
    #combo-count { font-size: 4rem; color: #ffeb3b; line-height: 1; }
    #combo-label { font-size: 1.2rem; color: #fff; letter-spacing: 2px; }
    #judge-display { top: 55%; left: 50%; transform: translate(-50%, -50%); font-size: 2.5rem; opacity: 0; }
    
    .judge-perfect { color: #ffeb3b; }
    .judge-great { color: #39c5bb; }
    .judge-good { color: #4caf50; }
    .judge-miss { color: #f44336; }
    
    #opponent-score-container { top: 50px; right: 10px; font-size: 1rem; color: #ff0055; background: rgba(0,0,0,0.5); padding: 5px 10px; border-radius: 5px; border: 1px solid #ff0055; }
    #btn-quit { top: 10px; left: 50%; transform: translateX(-50%); width: 80px; padding: 5px; font-size: 0.8rem; pointer-events: auto; background: rgba(255,0,0,0.3); color: #fff; border: 1px solid #f00; border-radius: 5px; cursor: pointer; }
    
    .lobby-user { padding: 8px; border-bottom: 1px solid #333; display: flex; flex-direction: column; cursor: pointer; }
    .lobby-user:hover { background: rgba(255,255,255,0.05); }
    .status-badge { font-size: 0.7rem; padding: 2px 5px; border-radius: 3px; margin-left: 10px; }
    .status-waiting { background: #39c5bb; color: #000; }
    .status-playing { background: #ff0055; color: #fff; }
    .matched { background: rgba(57, 197, 187, 0.2); border: 1px solid #39c5bb; }
    
    /* Autoplay Blocker Overlay */
    #autoplay-overlay { 
        position: absolute; top: 0; left: 0; width: 100%; height: 100%; 
        background: rgba(0,0,0,0.85); z-index: 100; display: flex; 
        flex-direction: column; align-items: center; justify-content: center; 
    }
    .play-icon { width: 0; height: 0; border-top: 20px solid transparent; border-bottom: 20px solid transparent; border-left: 35px solid #000; margin-left: 5px; }

    :root { --opponent: #ff0055; }
</style>
</head>
<body>

    <div id="background-layer">
        <div id="yt-player-container">
            <div id="yt-player"></div>
        </div>
        <div id="visualizer-overlay"></div>
    </div>

    <canvas id="game-layer"></canvas>

    <div id="ui-layer" class="hidden">
        <div id="life-container" class="hud-element"><div id="life-bar"></div></div>
        <div id="opponent-score-container" class="hud-element hidden">
            VS: <span id="opponent-name-hud">Opponent</span> - <span id="opponent-score-val">0</span>
        </div>
        <button id="btn-quit" class="hud-element">QUIT</button>
        <div id="score-display" class="hud-element">SCORE: <span id="score-val">0</span></div>
        <div id="combo-container" class="hud-element">
            <div id="combo-count">0</div>
            <div id="combo-label">COMBO</div>
        </div>
        <div id="judge-display" class="hud-element">PERFECT</div>
    </div>

    <div id="autoplay-overlay" class="hidden">
        <h2 style="margin-bottom:20px; color:#fff;">READY TO START</h2>
        <button id="force-start-btn" class="btn" style="width: 100px; height: 100px; border-radius: 50%; display: flex; align-items: center; justify-content: center; padding: 0;">
            <div class="play-icon"></div>
        </button>
        <p style="margin-top:20px; color:#aaa; font-size:0.9rem;">Tap to play music</p>
    </div>

    <div class="screen-container">
        
        <div id="title-screen" class="screen">
            <div class="screen-content">
                <img src="https://i.imgur.com/ujQpGlp.png" alt="Logo" class="title-logo">
                <h1>ホロの音ゲー</h1>
                <p>Made by Yytanuki</p>
                <div id="loading-message">Loading Song List...</div>
                
                <div class="settings-group hidden" id="menu-content">
                    <div id="main-menu-buttons">
                        <button id="btn-solo" class="btn">SOLO PLAY</button>
                        <button id="btn-collab" class="btn btn-collab">COLLAB MODE</button>
                    </div>

                    <div id="song-select-area" class="hidden">
                         <div id="collab-info" class="hidden">
                            <div class="lobby-status">COLLAB LOBBY</div>
                            <input type="text" id="player-name" placeholder="Enter Your Name" maxlength="10" value="Guest">
                            <div style="font-size:0.8rem; margin:5px 0;">Select a song or click a player to join</div>
                            <div id="lobby-list">
                                <div style="color:#888; text-align:center;">Looking for players...</div>
                            </div>
                         </div>

                        <div style="grid-column: 1 / -1;">
                            <label>SELECT SONG</label>
                            <div id="search-container">
                                <input type="text" id="song-search" placeholder="Type to search..." autocomplete="off" style="width:100%; padding:8px; box-sizing:border-box;">
                                <div id="song-list-scroll">
                                </div>
                            </div>
                        </div>
                        <div>
                            <label>DIFFICULTY</label>
                            <select id="diff-select" style="width:100%; padding:8px;">
                                <option value="0">EASY</option>
                                <option value="1">NORMAL</option>
                                <option value="2">HARD</option>
                                <option value="3">EXPERT</option>
                                <option value="4">MASTER</option>
                            </select>
                        </div>
                        <div>
                            <label>SPEED: <span id="speed-val">12.0</span></label>
                            <input type="range" id="speed-range" min="1" max="15" step="0.5" value="12.0" style="width:100%;">
                        </div>
                        <button id="start-btn" class="btn" disabled>SELECT A SONG</button>
                        <button id="back-btn" class="btn" style="background:transparent; border:1px solid #aaa; font-size:0.9rem; padding:10px 20px; margin-top:5px;">BACK</button>
                    </div>
                </div>
                <div class="footer-container" style="margin-top:20px;">
                    <a href="https://x.com/TanukiYy" target="_blank" class="btn btn-footer">作者X</a>
                    <a href="https://forms.gle/sM3ctNs1gpm1eiBBA" target="_blank" class="btn btn-footer">曲のリクエストやバグ報告</a>
                </div>
                <div class="footer-container2" style="margin-top:10px; font-size:0.7rem; color:#666;">
                        <p>音源や映像はYouTube埋め込みです。<br>非公式ファンサイト。</p>
                </div>
            </div>
        </div>

        <div id="loading-screen" class="screen hidden">
            <div class="screen-content">
                <h2>LOADING DATA...</h2>
                <div id="match-status" style="margin-top:20px; color:var(--opponent); display:none;">OPPONENT FOUND! STARTING...</div>
            </div>
        </div>

        <div id="result-screen" class="screen hidden">
            <div class="screen-content">
                <h2 id="res-title" style="font-size:3rem; margin-bottom:10px;">FULL COMBO!</h2>
                
                <div id="collab-result-area" style="display:none; margin-bottom:20px; padding:20px; background:rgba(255,153,0,0.1); border:2px solid var(--opponent); border-radius:10px;">
                    <h3 id="win-lose-text" style="font-size:2.5rem; margin:0;">WIN</h3>
                    <div style="display:flex; gap:20px; justify-content:center; margin-top:10px;">
                        <div>YOU: <span id="my-final-score">0</span></div>
                        <div>VS: <span id="op-final-score">0</span></div>
                    </div>
                </div>

                <div style="font-size:1.5rem;">SCORE: <span id="result-score">0</span></div>
                <div style="font-size:1.2rem; margin:10px;">MAX COMBO: <span id="result-combo">0</span></div>
                <div style="display:grid; grid-template-columns: 1fr 1fr; gap:15px; text-align:left; margin:20px; background:rgba(255,255,255,0.1); padding:20px; border-radius:10px;">
                    <div class="judge-perfect">PERFECT</div><div id="res-perf">0</div>
                    <div class="judge-great">GREAT</div><div id="res-great">0</div>
                    <div class="judge-good">GOOD</div><div id="res-good">0</div>
                    <div class="judge-miss">MISS</div><div id="res-miss">0</div>
                </div>
                <button class="btn" onclick="game.returnToTitle()">BACK TO TITLE</button>
            </div>
        </div>
    </div>

<script src="https://unpkg.com/mqtt/dist/mqtt.min.js"></script>

<script>
// Initialize Game Global
let game;

// --- Constants ---
const LANES = 4;
const PERFECT_WINDOW = 0.050;
const GREAT_WINDOW = 0.100;
const GOOD_WINDOW = 0.150;
const GAP_WINDOW = 0.150; 
const DIFF_NAMES = ["EASY", "NORMAL", "HARD", "EXPERT", "MASTER"];

// --- YouTube API Setup ---
let player;
let isYoutubeReady = false;

function onYouTubeIframeAPIReady() {
    player = new YT.Player('yt-player', {
        height: '100%',
        width: '100%',
        videoId: '', 
        playerVars: {
            'autoplay': 0, 'controls': 0, 'disablekb': 1,      
            'fs': 0, 'iv_load_policy': 3, 'modestbranding': 1,
            'rel': 0, 'playsinline': 1    
        },
        events: {
            'onReady': onPlayerReady,
            'onStateChange': onPlayerStateChange
        }
    });
}

function onPlayerReady(event) {
    isYoutubeReady = true;
    console.log("YouTube Player Ready");
}

function onPlayerStateChange(event) {
    // Only finish game if we are actively playing
    if (event.data === YT.PlayerState.ENDED && game && game.isPlaying) {
        game.finishGame();
    }
}

// Load YouTube API
const tag = document.createElement('script');
tag.src = "https://www.youtube.com/iframe_api";
const firstScriptTag = document.getElementsByTagName('script')[0];
firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);


// --- Multiplayer Manager (MQTT Version) ---
class MultiplayerManager {
    constructor() {
        this.client = null;
        // Public Free Broker
        this.brokerUrl = 'wss://broker.emqx.io:8084/mqtt';
        this.topic = 'holo-rhythm-game-2025/global';
        
        this.myId = 'user-' + Math.floor(Math.random() * 100000);
        this.myName = "Guest" + Math.floor(Math.random() * 1000);
        
        // Internal State
        this.myStatus = 'IDLE'; // IDLE, WAITING, PLAYING
        this.currentSongIndex = -1;
        this.currentDiff = 1;
        this.currentScore = 0;
        
        // Peers List: Map<id, {data, timestamp}>
        this.peers = new Map();
        
        // Opponent Info
        this.opponentId = null;
        this.opponentName = "";
        this.opponentScore = 0;
        
        this.heartbeatInterval = null;
        this.cleanupInterval = null;
        this.connected = false;
    }

    init() {
        if (this.connected) return;

        console.log("Connecting to Free MQTT Broker...");
        this.client = mqtt.connect(this.brokerUrl);

        this.client.on('connect', () => {
            console.log("MQTT Connected!");
            this.connected = true;
            this.client.subscribe(this.topic, (err) => {
                if (!err) {
                    console.log("Subscribed to lobby topic");
                    this.startHeartbeat();
                }
            });
        });

        this.client.on('message', (topic, message) => {
            try {
                const data = JSON.parse(message.toString());
                this.handleMessage(data);
            } catch (e) {
                // Ignore malformed messages
            }
        });

        this.client.on('error', (err) => {
            console.error('Connection error: ', err);
            this.client.end();
        });
    }

    startHeartbeat() {
        this.heartbeatInterval = setInterval(() => {
            if (!this.connected) return;
            const payload = {
                id: this.myId,
                name: this.myName,
                status: this.myStatus,
                songIndex: this.currentSongIndex,
                difficulty: this.currentDiff,
                score: this.currentScore,
                opponentId: this.opponentId 
            };
            this.client.publish(this.topic, JSON.stringify(payload));
        }, 1000);

        this.cleanupInterval = setInterval(() => {
            const now = Date.now();
            this.peers.forEach((val, key) => {
                if (now - val.timestamp > 3000) {
                    this.peers.delete(key);
                    this.updateLobbyUI(); 
                }
            });
        }, 2000);
    }

    updateMyPresence() {
        if (this.connected) {
            const payload = {
                id: this.myId,
                name: this.myName,
                status: this.myStatus,
                songIndex: this.currentSongIndex,
                difficulty: this.currentDiff,
                score: this.currentScore,
                opponentId: this.opponentId
            };
            this.client.publish(this.topic, JSON.stringify(payload));
        }
    }

    handleMessage(data) {
        if (data.id === this.myId) return; 

        this.peers.set(data.id, { data: data, timestamp: Date.now() });

        if (this.myStatus === 'IDLE' || this.myStatus === 'WAITING') {
            this.updateLobbyUI();
        }

        // Matching Logic
        if (this.myStatus === 'WAITING' && data.status === 'WAITING') {
            if (data.songIndex === this.currentSongIndex && data.difficulty === this.currentDiff) {
                // Match Found!
                this.foundMatch(data.id, data.name);
            }
        }
        
        // Opponent Score Update
        if (this.myStatus === 'PLAYING' && data.id === this.opponentId) {
            this.opponentScore = data.score;
            const opScoreEl = document.getElementById('opponent-score-val');
            if(opScoreEl) opScoreEl.innerText = this.opponentScore;
        }
    }

    updateLobbyUI() {
        const lobbyList = document.getElementById('lobby-list');
        if (!lobbyList || game.isPlaying) return;

        lobbyList.innerHTML = '';
        let count = 0;

        if(!game.songList || game.songList.length === 0) return;

        this.peers.forEach((peer) => {
            const state = peer.data;
            const div = document.createElement('div');
            div.className = 'lobby-user';
            
            let statusText = state.status;
            let badgeClass = 'status-badge';
            let extraInfo = '';
            let canJoin = false;
            
            if (state.status === 'WAITING') {
                if (state.songIndex === this.currentSongIndex && state.difficulty === this.currentDiff) {
                    statusText = "MATCHING...";
                    div.classList.add('matched');
                } else {
                    statusText = "WAITING";
                    badgeClass += ' status-waiting';
                    
                    const sName = game.songList[state.songIndex] ? game.songList[state.songIndex].name : "Unknown";
                    const dName = DIFF_NAMES[state.difficulty] || "?";
                    
                    extraInfo = `
                    <div class="lobby-song-info">
                        ${sName} [${dName}] <span class="lobby-join-hint">CLICK TO JOIN</span>
                    </div>`;
                    
                    canJoin = true;
                }
            } else if (state.status === 'PLAYING') {
                badgeClass += ' status-playing';
                const sName = game.songList[state.songIndex] ? game.songList[state.songIndex].name : "Unknown";
                extraInfo = `<div class="lobby-song-info">Playing: ${sName}</div>`;
            } else {
                statusText = "IDLE";
            }

            div.innerHTML = `
                <div class="lobby-user-header">
                    <span style="font-weight:bold;">${state.name}</span>
                    <span class="${badgeClass}">${statusText}</span>
                </div>
                ${extraInfo}
            `;

            if (canJoin) {
                div.onclick = () => {
                    game.joinSpecificLobby(state.songIndex, state.difficulty);
                };
            }

            lobbyList.appendChild(div);
            count++;
        });

        if (count === 0) lobbyList.innerHTML = '<div style="color:#888; text-align:center;">No other players online.</div>';
    }

    startWaiting(songIndex, diff) {
        this.currentSongIndex = songIndex;
        this.currentDiff = diff;
        this.myStatus = 'WAITING';
        this.currentScore = 0;
        this.opponentId = null;
        this.updateMyPresence();
        
        document.getElementById('start-btn').innerText = "WAITING FOR OPPONENT...";
        document.getElementById('start-btn').disabled = true;
    }

    cancelWaiting() {
        this.myStatus = 'IDLE';
        this.currentSongIndex = -1; // Reset song to avoid auto-match
        this.updateMyPresence();
        
        // Reset UI immediately
        const startBtn = document.getElementById('start-btn');
        if(startBtn) {
            // Check if a song is actually selected in UI to determine text
            if(game && game.selectedSongIndex !== null) {
                const sName = game.songList[game.selectedSongIndex].name;
                startBtn.innerText = game.isMultiplayerMode ? "WAIT FOR OPPONENT: " + sName : "START: " + sName;
                startBtn.disabled = false;
            } else {
                startBtn.innerText = "SELECT A SONG";
                startBtn.disabled = true;
            }
        }
    }

    foundMatch(opponentId, opponentName) {
        if (this.myStatus === 'PLAYING') return;

        console.log("Match Found!", opponentName);
        this.opponentId = opponentId;
        this.opponentName = opponentName;
        this.myStatus = 'PLAYING';
        this.updateMyPresence(); 

        game.startMultiplayerGame(opponentName);
    }
    
    updateScore(score) {
        this.currentScore = score;
    }
}

// --- Game Class ---
class RhythmGame {
    constructor() {
        this.isMultiplayerMode = false;
        this.mpManager = new MultiplayerManager();

        this.notes = [];
        this.score = 0;
        this.combo = 0;
        this.maxCombo = 0;
        this.life = 1000;
        this.isPlaying = false;
        
        // Load Speed from LocalStorage
        const savedSpeed = localStorage.getItem('holoNoteSpeed');
        this.noteSpeed = savedSpeed ? parseFloat(savedSpeed) : 8.0;

        this.difficulty = 1;
        this.stats = { perfect:0, great:0, good:0, miss:0 };
        
        this.keyMap = { 'KeyD':0, 'KeyF':1, 'KeyJ':2, 'KeyK':3 };
        this.laneState = [0, 0, 0, 0]; 
        this.touchLaneMap = new Map(); 
        
        this.canvas = document.getElementById('game-layer');
        this.ctx = this.canvas.getContext('2d');
        this.trackDims = { x:0, w:0, laneW:0 };
        
        this.resize();
        window.addEventListener('resize', () => this.resize());
        this.bindInputs();

        this.songList = [];
        this.selectedSongIndex = null;
        this.currentSongData = null; 
        this.currentYoutubeId = "";
        
        this.setupUI();
    }

    setupUI() {
        document.getElementById('btn-solo').addEventListener('click', () => {
            this.isMultiplayerMode = false;
            this.showSongSelect();
        });
        document.getElementById('btn-collab').addEventListener('click', () => {
            this.isMultiplayerMode = true;
            this.mpManager.init(); 
            document.getElementById('collab-info').classList.remove('hidden');
            document.getElementById('player-name').value = this.mpManager.myName;
            this.showSongSelect();
        });
        
        document.getElementById('back-btn').addEventListener('click', () => {
             document.getElementById('song-select-area').classList.add('hidden');
             document.getElementById('main-menu-buttons').classList.remove('hidden');
             document.getElementById('collab-info').classList.add('hidden');
             if(this.isMultiplayerMode) this.mpManager.cancelWaiting();
        });
        
        document.getElementById('player-name').addEventListener('input', (e) => {
            if(this.mpManager) {
                this.mpManager.myName = e.target.value || "Guest";
                this.mpManager.updateMyPresence();
            }
        });

        document.getElementById('song-search').addEventListener('input', (e) => this.renderSongList(e.target.value));
        
        // Speed Slider Setup (Initialize with saved value)
        const speedRange = document.getElementById('speed-range');
        const speedVal = document.getElementById('speed-val');
        speedRange.value = this.noteSpeed;
        speedVal.innerText = this.noteSpeed.toFixed(1);

        speedRange.addEventListener('input', (e) => {
            const val = parseFloat(e.target.value);
            speedVal.innerText = val.toFixed(1);
            this.noteSpeed = val;
            // Save to LocalStorage
            localStorage.setItem('holoNoteSpeed', val);
        });

        document.getElementById('diff-select').addEventListener('change', (e) => this.difficulty = parseInt(e.target.value));

        document.getElementById('start-btn').addEventListener('click', () => {
            if (this.selectedSongIndex === null) return;
            
            if (this.isMultiplayerMode) {
                this.mpManager.startWaiting(this.songList[this.selectedSongIndex].originalIndex, this.difficulty);
            } else {
                this.loadSelectedSong();
            }
        });

        document.getElementById('btn-quit').addEventListener('click', () => this.stopGame());
        
        // Manual Start Button (Fix for Autoplay Policy)
        document.getElementById('force-start-btn').addEventListener('click', () => {
            document.getElementById('autoplay-overlay').classList.add('hidden');
            if(player && typeof player.playVideo === 'function') {
                player.playVideo();
                this.isPlaying = true;
                this.loop();
            }
        });
    }

    showSongSelect() {
        document.getElementById('main-menu-buttons').classList.add('hidden');
        document.getElementById('song-select-area').classList.remove('hidden');
        this.renderSongList("");
    }
    
    joinSpecificLobby(songIdx, diff) {
        if (!this.isMultiplayerMode) return;
        
        // 1. Force Local State Update First
        this.selectedSongIndex = songIdx;
        this.difficulty = diff;
        
        // 2. Update UI Elements
        document.getElementById('diff-select').value = diff;
        this.renderSongList(""); 

        const songName = this.songList[songIdx].name;
        document.getElementById('start-btn').innerText = "JOINING: " + songName + "...";
        document.getElementById('start-btn').disabled = true;
        
        // 3. Enter Waiting Mode (Triggers Match)
        this.mpManager.startWaiting(songIdx, diff);
    }

    async fetchSongList() {
        try {
            const response = await fetch('./notes/note_list.txt');
            if (!response.ok) throw new Error("List not found");
            const text = await response.text();
            
            const regex = /(.+?)\((.+?),(.+?)\),?/g;
            let match;
            
            while ((match = regex.exec(text)) !== null) {
                const name = match[1].trim();
                const url = match[2].trim();
                const jsonFile = match[3].trim();
                
                let ytId = "";
                if (url.includes('v=')) ytId = url.split('v=')[1].split('&')[0];
                else if (url.includes('youtu.be/')) ytId = url.split('youtu.be/')[1].split('?')[0];
                
                this.songList.push({ name, ytId, jsonFile, originalIndex: this.songList.length });
            }
            
            document.getElementById('loading-message').style.display = 'none';
            document.getElementById('menu-content').classList.remove('hidden');

        } catch (e) {
            document.getElementById('loading-message').innerText = "ERROR: Could not load note_list.txt";
            console.error(e);
        }
    }

    renderSongList(query) {
        const listContainer = document.getElementById('song-list-scroll');
        listContainer.innerHTML = '';
        const startBtn = document.getElementById('start-btn');
        
        const terms = query.toLowerCase().split(/\s+/).filter(t => t.length > 0);

        const filtered = this.songList.filter(song => {
            if (terms.length === 0) return true;
            const target = song.name.toLowerCase();
            return terms.every(term => target.includes(term));
        });

        if (filtered.length === 0) {
            const div = document.createElement('div');
            div.className = 'no-result';
            div.innerText = 'No songs found.';
            listContainer.appendChild(div);
            return;
        }

        filtered.forEach(song => {
            const div = document.createElement('div');
            div.className = 'song-item';
            if (this.selectedSongIndex === song.originalIndex) {
                div.classList.add('selected');
            }
            div.innerText = song.name;
            
            div.addEventListener('click', () => {
                this.selectedSongIndex = song.originalIndex;
                document.querySelectorAll('.song-item').forEach(el => el.classList.remove('selected'));
                div.classList.add('selected');
                startBtn.disabled = false;
                
                if (this.isMultiplayerMode) {
                    startBtn.innerText = "WAIT FOR OPPONENT: " + song.name;
                } else {
                    startBtn.innerText = "START: " + song.name;
                }
                
                if(this.mpManager.myStatus === 'WAITING') {
                    this.mpManager.cancelWaiting();
                    startBtn.innerText = "WAIT FOR OPPONENT: " + song.name;
                }
            });
            
            listContainer.appendChild(div);
        });
    }

    async loadSelectedSong() {
        if (this.selectedSongIndex === null) return;
        
        const song = this.songList[this.selectedSongIndex];
        this.currentYoutubeId = song.ytId;

        document.getElementById('title-screen').classList.add('hidden');
        document.getElementById('loading-screen').classList.remove('hidden');

        try {
            const res = await fetch(`./notes/${song.jsonFile}`);
            if(!res.ok) throw new Error("JSON not found");
            this.currentSongData = await res.json();
            
            const chartData = this.currentSongData.charts[this.difficulty];
            
            if (!chartData || chartData.length === 0) {
                alert("This difficulty does not exist for this song.");
                this.returnToTitle(); // Safe exit
                return;
            }

            this.notes = JSON.parse(JSON.stringify(chartData));
            this.notes.forEach(n => {
                n.lastReleaseTime = 0; 
                n.missed = false; 
                n.finished = false; 
            });
            
            // Check Player Readiness
            if (isYoutubeReady && player) {
                player.cueVideoById(this.currentYoutubeId);
                // Wait a bit to ensure cueing finishes, then try start
                setTimeout(() => {
                    if (player && typeof player.playVideo === 'function') {
                        this.startGame();
                    } else {
                        alert("Video Player Error. Please try again.");
                        this.returnToTitle();
                    }
                }, 2000);
            } else {
                alert("YouTube Player not ready. Please refresh.");
                this.returnToTitle();
            }

        } catch (e) {
            alert("Error loading chart data: " + e.message);
            console.error(e);
            this.returnToTitle();
        }
    }

    startMultiplayerGame(opponentName) {
        document.getElementById('match-status').style.display = 'block';
        document.getElementById('match-status').innerText = `VS ${opponentName}! STARTING...`;
        
        // Show Loading Screen
        document.getElementById('title-screen').classList.add('hidden');
        document.getElementById('loading-screen').classList.remove('hidden');

        // Load data normally
        this.loadSelectedSong().then(() => {
            document.getElementById('opponent-score-container').classList.remove('hidden');
            document.getElementById('opponent-name-hud').innerText = opponentName;
            document.getElementById('opponent-score-val').innerText = "0";
        });
    }

    // --- Game Logic ---

    resize() {
        this.canvas.width = window.innerWidth;
        this.canvas.height = window.innerHeight;
        const trackW = Math.min(this.canvas.width, 800);
        const trackX = (this.canvas.width - trackW) / 2;
        this.trackDims = { x: trackX, w: trackW, laneW: trackW / LANES };
    }

    bindInputs() {
        window.addEventListener('keydown', (e) => {
            if (!this.isPlaying || e.repeat) return;
            if (e.code === 'Escape') this.stopGame();
            if (e.code in this.keyMap) {
                const lane = this.keyMap[e.code];
                this.handleInput(lane, 'down');
                this.laneState[lane] = 1; 
            }
        });
        window.addEventListener('keyup', (e) => {
            if (!this.isPlaying) return;
            if (e.code in this.keyMap) {
                const lane = this.keyMap[e.code];
                this.handleInput(lane, 'up');
                this.laneState[lane] = 0;
            }
        });

        this.canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            if (!this.isPlaying) return;
            
            for (let i = 0; i < e.changedTouches.length; i++) {
                const t = e.changedTouches[i];
                const lane = this.getLaneFromX(t.clientX);
                if (lane !== -1) {
                    this.touchLaneMap.set(t.identifier, lane);
                    this.handleInput(lane, 'down');
                    this.laneState[lane]++; 
                }
            }
        }, { passive: false });

        const handleTouchEnd = (e) => {
            e.preventDefault();
            if (!this.isPlaying) return;
            
            for (let i = 0; i < e.changedTouches.length; i++) {
                const t = e.changedTouches[i];
                const lane = this.touchLaneMap.get(t.identifier);

                if (lane !== undefined) {
                    this.handleInput(lane, 'up');
                    this.laneState[lane] = Math.max(0, this.laneState[lane] - 1);
                    this.touchLaneMap.delete(t.identifier);
                }
            }
        };

        this.canvas.addEventListener('touchend', handleTouchEnd);
        this.canvas.addEventListener('touchcancel', handleTouchEnd);
    }

    getLaneFromX(x) {
        if (x < this.trackDims.x || x > this.trackDims.x + this.trackDims.w) return -1;
        return Math.floor((x - this.trackDims.x) / this.trackDims.laneW);
    }

    startGame() {
        document.getElementById('loading-screen').classList.add('hidden');
        document.getElementById('match-status').style.display = 'none';
        document.getElementById('ui-layer').classList.remove('hidden');
        
        // Reset Logic
        this.score = 0;
        this.combo = 0;
        this.life = 1000;
        this.stats = { perfect:0, great:0, good:0, miss:0 };
        this.laneState = [0, 0, 0, 0];
        this.touchLaneMap.clear();

        document.getElementById('combo-count').innerText = "0";
        document.getElementById('combo-container').style.display = 'none';
        
        if (!this.isMultiplayerMode) {
            document.getElementById('opponent-score-container').classList.add('hidden');
            document.getElementById('opponent-name-hud').innerText = "";
            document.getElementById('opponent-score-val').innerText = "0";
        }

        this.updateHUD();

        // **FIX: AUTOPLAY POLICY HANDLING**
        // Attempt to play
        if(player && typeof player.playVideo === 'function') {
            player.playVideo();
        }

        this.isPlaying = true;
        
        // Wait briefly to see if browser blocked autoplay
        setTimeout(() => {
            // Check if video is NOT playing (1 = Playing, 3 = Buffering)
            // If it is -1 (unstarted), 0 (ended), 2 (paused), or 5 (cued) after we tried to play...
            const state = player.getPlayerState();
            if (state !== YT.PlayerState.PLAYING && state !== YT.PlayerState.BUFFERING) {
                console.warn("Autoplay blocked or slow connection. Showing manual start button.");
                this.isPlaying = false; // Pause logic until user clicks
                document.getElementById('autoplay-overlay').classList.remove('hidden');
            }
        }, 800);

        this.loop();
    }

    stopGame() {
        this.isPlaying = false;
        if (player && typeof player.pauseVideo === 'function') {
            player.pauseVideo();
        }
        if (this.isMultiplayerMode) {
             this.mpManager.cancelWaiting();
             document.getElementById('opponent-score-container').classList.add('hidden');
        }
        document.getElementById('autoplay-overlay').classList.add('hidden');
        this.returnToTitle();
    }

    returnToTitle() {
        // Reset Screens
        document.getElementById('result-screen').classList.add('hidden');
        document.getElementById('ui-layer').classList.add('hidden');
        document.getElementById('loading-screen').classList.add('hidden'); 
        document.getElementById('title-screen').classList.remove('hidden');
        document.getElementById('autoplay-overlay').classList.add('hidden');
        
        // Reset Menus
        document.getElementById('song-select-area').classList.add('hidden');
        document.getElementById('main-menu-buttons').classList.remove('hidden');
        document.getElementById('collab-info').classList.add('hidden');

        // Clear Canvas
        this.ctx.clearRect(0,0,this.canvas.width, this.canvas.height);
        
        // Reset Game Modes and Multiplayer Status
        this.isMultiplayerMode = false;
        if(this.mpManager) {
            this.mpManager.cancelWaiting(); 
        }
        
        document.getElementById('opponent-score-container').classList.add('hidden');

        const btn = document.getElementById('start-btn');
        btn.innerText = "SELECT A SONG";
        btn.disabled = true;
        this.selectedSongIndex = null;
        document.querySelectorAll('.song-item').forEach(el => el.classList.remove('selected'));
    }

    getCurrentTime() {
        if (!player || !this.isPlaying) return 0;
        return player.getCurrentTime();
    }

    handleInput(lane, action) {
        const now = this.getCurrentTime();

        if (action === 'down') {
            const normalNotes = this.notes.filter(n => 
                !n.hit && !n.missed && n.lane === lane && n.type !== 'end' && n.type !== 'long' &&
                Math.abs(n.time - now) < GOOD_WINDOW
            );
            
            normalNotes.sort((a,b) => Math.abs(a.time - now) - Math.abs(b.time - now));
            
            if (normalNotes.length > 0) {
                this.judge(normalNotes[0], now);
            }
            
            const longStarts = this.notes.filter(n => 
                !n.hit && !n.missed && n.lane === lane && n.type === 'long' &&
                Math.abs(n.time - now) < GOOD_WINDOW
            );
            
            if (longStarts.length > 0) {
                const note = longStarts[0];
                note.holding = true;
                this.judge(note, now);
            }

            const suspendedNotes = this.notes.filter(n => 
                n.hit && n.type === 'long' && 
                !n.holding && !n.finished && !n.missed &&
                n.lane === lane && (now < n.time + n.length)
            );

            suspendedNotes.forEach(n => {
                if (now - n.lastReleaseTime <= GAP_WINDOW) {
                    n.holding = true;
                }
            });

        } else if (action === 'up') {
            if (this.laneState[lane] <= 1) { 
                const activeLongs = this.notes.filter(n => 
                    n.hit && n.type === 'long' && n.holding && n.lane === lane && !n.finished
                );
                
                activeLongs.forEach(n => {
                    n.holding = false;
                    n.lastReleaseTime = now;
                });
            }
        }
    }

    judge(note, now) {
        const diff = Math.abs(note.time - now);
        
        let grade = 'MISS';
        if (diff <= PERFECT_WINDOW) grade = 'PERFECT';
        else if (diff <= GREAT_WINDOW) grade = 'GREAT';
        else if (diff <= GOOD_WINDOW) grade = 'GOOD';

        if (grade !== 'MISS') {
            note.hit = true;
            this.addScore(grade);
        } else {
            note.hit = true;
            this.breakCombo();
        }
    }

    addScore(grade) {
        this.combo++;
        if(this.combo > this.maxCombo) this.maxCombo = this.combo;
        let val = 500;
        if (grade === 'PERFECT') val = 1000;
        if (grade === 'GREAT') val = 800;
        this.score += Math.floor(val * (1 + Math.min(this.combo, 100) * 0.01));
        
        if (grade==='PERFECT') this.stats.perfect++;
        else if (grade==='GREAT') this.stats.great++;
        else this.stats.good++;

        this.life = Math.min(1000, this.life + 15);
        this.showJudge(grade);
        this.updateHUD();

        if (this.isMultiplayerMode && this.mpManager) {
            this.mpManager.updateScore(this.score);
        }
    }

    breakCombo() {
        this.combo = 0;
        this.stats.miss++;
        this.life = Math.max(0, this.life - 50);
        this.showJudge('MISS');
        this.updateHUD();
        
        if (this.isMultiplayerMode && this.mpManager) {
            this.mpManager.updateScore(this.score);
        }
    }

    showJudge(text) {
        const el = document.getElementById('judge-display');
        el.innerText = text;
        el.className = 'judge-' + text.toLowerCase() + ' hud-element';
        el.style.animation = 'none';
        el.offsetHeight; 
        el.style.animation = 'pop 0.2s forwards';
        el.style.opacity = 1;

        const c = document.getElementById('combo-container');
        if (this.combo > 1) {
            document.getElementById('combo-count').innerText = this.combo;
            c.style.display = 'block';
            c.style.animation = 'none';
            c.offsetHeight;
            c.style.animation = 'bump 0.1s';
        } else {
            c.style.display = 'none';
        }
    }

    updateHUD() {
        document.getElementById('score-val').innerText = this.score;
        const bar = document.getElementById('life-bar');
        bar.style.width = (this.life / 10) + '%';
        bar.style.background = this.life > 300 ? '#4caf50' : '#f44336';
    }

    finishGame() {
        if (!this.isPlaying) return;
        this.isPlaying = false;
        if (player) player.pauseVideo();
        document.getElementById('ui-layer').classList.add('hidden');
        document.getElementById('result-screen').classList.remove('hidden');
        
        const title = this.stats.miss === 0 ? "FULL COMBO!" : "FINISH";
        document.getElementById('res-title').innerText = title;
        document.getElementById('result-score').innerText = this.score;
        document.getElementById('result-combo').innerText = this.maxCombo;
        document.getElementById('res-perf').innerText = this.stats.perfect;
        document.getElementById('res-great').innerText = this.stats.great;
        document.getElementById('res-good').innerText = this.stats.good;
        document.getElementById('res-miss').innerText = this.stats.miss;

        const collabArea = document.getElementById('collab-result-area');
        if (this.isMultiplayerMode) {
            collabArea.style.display = 'block';
            document.getElementById('my-final-score').innerText = this.score;
            document.getElementById('op-final-score').innerText = this.mpManager.opponentScore;
            
            const winText = document.getElementById('win-lose-text');
            if (this.score > this.mpManager.opponentScore) {
                winText.innerText = "WIN!";
                winText.style.color = "#39c5bb";
            } else if (this.score < this.mpManager.opponentScore) {
                winText.innerText = "LOSE...";
                winText.style.color = "#ff0055";
            } else {
                winText.innerText = "DRAW";
                winText.style.color = "#fff";
            }
            this.mpManager.cancelWaiting();
        } else {
            collabArea.style.display = 'none';
        }
    }

    loop() {
        if (!this.isPlaying) return;
        requestAnimationFrame(() => this.loop());

        const now = this.getCurrentTime();
        this.ctx.clearRect(0,0, this.canvas.width, this.canvas.height);

        const w = this.canvas.width;
        const h = this.canvas.height;
        const { x: trackX, w: trackW, laneW } = this.trackDims;

        const project = (laneX, timeDiff) => {
            const speedFactor = this.noteSpeed / 2.0;
            const zDepth = 1 + (timeDiff * speedFactor); 

            if (zDepth < 0.1) return null;
            const scale = 1 / zDepth;
            const vpY = h * 0.15; 
            const playerY = h * 0.90;
            const trackScreenHeight = playerY - vpY;
            const y = vpY + (trackScreenHeight * scale);
            const centerX = w / 2;
            const x = centerX + (laneX - centerX) * scale;
            return { x, y, scale };
        };

        const btmL = project(trackX, 0);
        const btmR = project(trackX + trackW, 0);
        const topL = project(trackX, 100); 
        const topR = project(trackX + trackW, 100);
        
        const grad = this.ctx.createLinearGradient(0, topL.y, 0, btmL.y);
        grad.addColorStop(0, 'rgba(0,0,0,0)');
        grad.addColorStop(1, 'rgba(0, 20, 30, 0.8)');
        this.ctx.fillStyle = grad;
        
        this.ctx.beginPath();
        this.ctx.moveTo(btmL.x, btmL.y);
        this.ctx.lineTo(btmR.x, btmR.y);
        this.ctx.lineTo(topR.x, topR.y);
        this.ctx.lineTo(topL.x, topL.y);
        this.ctx.fill();

        this.ctx.strokeStyle = 'rgba(57, 197, 187, 0.3)';
        this.ctx.lineWidth = 2;
        for(let i=0; i<=LANES; i++) {
            const p1 = project(trackX + i*laneW, 0);
            const p2 = project(trackX + i*laneW, 100);
            this.ctx.beginPath();
            this.ctx.moveTo(p1.x, p1.y);
            this.ctx.lineTo(p2.x, p2.y);
            this.ctx.stroke();
        }

        this.ctx.strokeStyle = '#fff';
        this.ctx.lineWidth = 4;
        this.ctx.beginPath();
        this.ctx.moveTo(btmL.x, btmL.y);
        this.ctx.lineTo(btmR.x, btmR.y);
        this.ctx.stroke();

        for(let i=0; i<LANES; i++) {
            if(this.laneState[i] > 0) {
                const p1 = project(trackX + i*laneW, 0);
                const p2 = project(trackX + (i+1)*laneW, 0);
                const p3 = project(trackX + i*laneW, 0.5); 
                
                const fGrad = this.ctx.createLinearGradient(0, p3.y, 0, p1.y);
                fGrad.addColorStop(0, 'rgba(255, 0, 85, 0.0)');
                fGrad.addColorStop(1, 'rgba(255, 0, 85, 0.6)');
                this.ctx.fillStyle = fGrad;
                
                const beamTopL = project(trackX + i*laneW, 0.5);
                const beamTopR = project(trackX + (i+1)*laneW, 0.5);
                
                this.ctx.beginPath();
                this.ctx.moveTo(p1.x, p1.y);
                this.ctx.lineTo(p2.x, p2.y);
                this.ctx.lineTo(beamTopR.x, beamTopR.y);
                this.ctx.lineTo(beamTopL.x, beamTopL.y);
                this.ctx.fill();
            }
        }

        this.notes.forEach(note => {
            if (note.type === 'long' && note.hit && !note.finished && !note.missed) {
                const endTime = note.time + note.length;

                if (now >= endTime) {
                    note.finished = true;
                    this.addScore('PERFECT');
                    return; 
                }

                if (!note.holding) {
                    if (now - note.lastReleaseTime > GAP_WINDOW) {
                        this.breakCombo();
                        note.missed = true;
                        note.finished = true;
                        return;
                    }
                }
            }

            if (note.finished || note.missed) return;
            if (note.hit && note.type !== 'long') return;
            
            const dt = note.time - now;
            if (dt > 10.0 / (this.noteSpeed/2)) return; 
            
            if (dt < -0.2 && note.type !== 'long') {
                if(!note.hit) { note.hit = true; note.missed = true; this.breakCombo(); }
                return;
            }
            if (note.type === 'end' && dt < 0) { this.finishGame(); return; }
            if (note.type === 'end') return;

            const laneX = trackX + note.lane * laneW;

            if (note.type === 'long') {
                const dtTail = (note.time + note.length) - now;
                if (dtTail < 0) return; 

                const effDt = (note.hit) ? 0 : Math.max(0, dt);
                
                const headP = project(laneX, effDt);
                const headPR = project(laneX + laneW, effDt);
                const tailP = project(laneX, dtTail);
                const tailPR = project(laneX + laneW, dtTail);

                if (headP && tailP) {
                    if (note.hit && !note.holding) {
                        this.ctx.fillStyle = 'rgba(255, 100, 100, 0.6)'; 
                    } else {
                        this.ctx.fillStyle = 'rgba(57, 197, 187, 0.7)';
                    }
                    
                    this.ctx.beginPath();
                    this.ctx.moveTo(headP.x, headP.y);
                    this.ctx.lineTo(headPR.x, headPR.y);
                    this.ctx.lineTo(tailPR.x, tailPR.y);
                    this.ctx.lineTo(tailP.x, tailP.y);
                    this.ctx.fill();
                }
            }

            if (!note.hit) {
                const renderDt = dt;
                if (renderDt < -0.1) return;

                const p = project(laneX, renderDt);
                const pR = project(laneX + laneW, renderDt);
                
                if (p && pR) {
                    const wNote = pR.x - p.x;
                    const hNote = 20 * p.scale; 

                    if (note.type === 'flick') this.ctx.fillStyle = '#ff0055';
                    else if (note.type === 'long') this.ctx.fillStyle = '#ffeb3b';
                    else this.ctx.fillStyle = '#39c5bb';

                    this.ctx.fillRect(p.x + 1, p.y - hNote/2, wNote - 2, hNote);
                    this.ctx.fillStyle = '#fff';
                    this.ctx.fillRect(p.x + 3, p.y - hNote/4, wNote - 6, hNote/2);

                    if (note.type === 'flick') {
                        this.ctx.fillStyle = '#ff0055';
                        this.ctx.beginPath();
                        this.ctx.moveTo(p.x + wNote/2, p.y - hNote);
                        this.ctx.lineTo(p.x + wNote/2 - 15*p.scale, p.y - hNote/2);
                        this.ctx.lineTo(p.x + wNote/2 + 15*p.scale, p.y - hNote/2);
                        this.ctx.fill();
                    }
                }
            }
        });
    }
}

game = new RhythmGame();
game.fetchSongList();

const styleSheet = document.createElement("style");
styleSheet.innerText = `
@keyframes pop { 0% { transform: translate(-50%, -50%) scale(0.5); opacity: 0; } 50% { transform: translate(-50%, -50%) scale(1.3); opacity: 1; } 100% { transform: translate(-50%, -50%) scale(1.0); opacity: 0; } }
@keyframes bump { 0% { transform: translate(-50%, -50%) scale(1); } 50% { transform: translate(-50%, -50%) scale(1.2); } 100% { transform: translate(-50%, -50%) scale(1); } }
`;
document.head.appendChild(styleSheet);
</script>
</body>
</html>
